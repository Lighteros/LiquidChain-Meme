import{a as J,b as It}from"./chunk-VN6YWX5N.js";import{b as Ot,c as Ar,d as Sr}from"./chunk-RREIECOL.js";import"./chunk-ICS5LBCC.js";import"./chunk-CHO3IBPB.js";import"./chunk-LVKJ32IM.js";import"./chunk-RREX6AKU.js";import"./chunk-O63J7XX2.js";import{b as ke,c as bt,d as mr}from"./chunk-YVK6EA54.js";import"./chunk-SK5RHXGA.js";import{d as et,e as hr,f as _r,g as gr,h as pr}from"./chunk-MGL7NSAW.js";import"./chunk-CT4HELHY.js";import"./chunk-LI53BOMV.js";import"./chunk-ICDT4GZS.js";import"./chunk-TSLWMKS5.js";import"./chunk-IV5FR2YO.js";import{a as ye,b as Nt,c as H}from"./chunk-IXYUL4FP.js";import{a as Ce,b as Js,c as Zs,e as Qs,f as We,g as eo,h as yr,i as Rr,j as to}from"./chunk-JJB6F2M2.js";import{a as js,b as Xs}from"./chunk-3DJS6E6H.js";import{w as Et,x as Ys}from"./chunk-4I7G342N.js";import"./chunk-VAHX4GR7.js";import"./chunk-I2YJHZ2B.js";import{D as lr,F as fr,Q as Te,a as rr,b as sr,c as or,d as ir,h as Ke,i as cr,s as ur,x as dr}from"./chunk-XLSZADC6.js";import"./chunk-YSWAE63R.js";import{b as K,i as ar,k as St}from"./chunk-CDMUM2L7.js";import"./chunk-QSWUHUZZ.js";import"./chunk-AX3MU5C4.js";import"./chunk-ZRBE6OMV.js";import{a as un,b as qs}from"./chunk-Z3SE2D4B.js";import"./chunk-5LQ6A2AX.js";import"./chunk-5G3DVQVW.js";import{a as cn,b as Hs}from"./chunk-HINDXNTT.js";import"./chunk-X3F4NDXO.js";import"./chunk-JKZLGYQN.js";import"./chunk-EEU3LH2V.js";import"./chunk-TRLFM7P4.js";import"./chunk-QMRWXCSQ.js";import{a as w,b as L,f as le,h as Gs,k as oe,m as ze,n as d}from"./chunk-VNDKUXGB.js";var br=Gs((Ol,Er)=>{"use strict";var no=Zs(),ro="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";Er.exports=no(ro)});var k=oe(js());Js();var Tn=oe(Xs()),j=oe(br());qs();var Ye=oe(Qs()),u=oe(We()),os=oe(We());var so=1,oo=2,io=3,ao=4,co=5,uo=6,lo=7,fo=8,ho=9,_o=10,go=-32700,po=-32603,mo=-32602,yo=-32601,Ro=-32600,Ao=-32016,So=-32015,Eo=-32014,bo=-32013,Io=-32012,Oo=-32011,No=-32010,wo=-32009,To=-32008,ko=-32007,Co=-32006,Lo=-32005,vo=-32004,Po=-32003,Bo=-32002,xo=-32001,Do=28e5,Uo=2800001,Mo=2800002,zo=2800003,Ko=2800004,Wo=2800005,Fo=2800006,$o=2800007,Vo=2800008,Go=2800009,Ho=2800010,qo=2800011,jo=323e4,Yo=32300001,Xo=3230002,Jo=3230003,Zo=3230004,Qo=361e4,ei=3610001,ti=3610002,ni=3610003,ri=3610004,si=3610005,oi=3610006,ii=3610007,ai=3611e3,ci=3704e3,ui=3704001,di=3704002,li=3704003,fi=3704004,hi=4128e3,_i=4128001,gi=4128002,pi=4615e3,mi=4615001,yi=4615002,Ri=4615003,Ai=4615004,Si=4615005,Ei=4615006,bi=4615007,Ii=4615008,Oi=4615009,Ni=4615010,wi=4615011,Ti=4615012,ki=4615013,Ci=4615014,Li=4615015,vi=4615016,Pi=4615017,Bi=4615018,xi=4615019,Di=4615020,Ui=4615021,Mi=4615022,zi=4615023,Ki=4615024,Wi=4615025,Fi=4615026,$i=4615027,Vi=4615028,Gi=4615029,Hi=4615030,qi=4615031,ji=4615032,Yi=4615033,Xi=4615034,Ji=4615035,Zi=4615036,Qi=4615037,ea=4615038,ta=4615039,na=4615040,ra=4615041,sa=4615042,oa=4615043,ia=4615044,aa=4615045,ca=4615046,ua=4615047,da=4615048,la=4615049,fa=4615050,ha=4615051,_a=4615052,ga=4615053,pa=4615054,ma=5508e3,ya=5508001,Ra=5508002,Aa=5508003,Sa=5508004,Ea=5508005,ba=5508006,Ia=5508007,Oa=5508008,Na=5508009,wa=5508010,Ta=5508011,ka=5663e3,Ca=5663001,La=5663002,va=5663003,Pa=5663004,Ba=5663005,xa=5663006,Da=5663007,Ua=5663008,Ma=5663009,za=5663010,Ka=5663011,Wa=5663012,Fa=5663013,$a=5663014,Va=5663015,Ga=5663016,Ha=5663017,qa=5663018,ja=5663019,Ya=5663020,Xa=705e4,Ja=7050001,Za=7050002,Qa=7050003,ec=7050004,tc=7050005,nc=7050006,rc=7050007,sc=7050008,oc=7050009,ic=7050010,ac=7050011,cc=7050012,uc=7050013,dc=7050014,lc=7050015,fc=7050016,hc=7050017,_c=7050018,gc=7050019,pc=7050020,mc=7050021,yc=7050022,Rc=7050023,Ac=7050024,Sc=7050025,Ec=7050026,bc=7050027,Ic=7050028,Oc=7050029,Nc=7050030,wc=7050031,Tc=7050032,kc=7050033,Cc=7050034,Lc=7050035,vc=7050036,dn=8078e3,ln=8078001,Ir=8078002,Or=8078003,fn=8078004,hn=8078005,_n=8078006,Pc=8078007,Bc=8078008,xc=8078009,Dc=8078010,gn=8078011,Uc=8078012,Nr=8078013,wr=8078014,Mc=8078015,zc=8078016,Kc=8078017,Wc=8078018,Fc=8078019,Tr=8078020,kr=8078021,$c=8078022,Vc=81e5,Gc=8100001,Hc=8100002,qc=8100003,jc=819e4,Yc=8190001,Xc=8190002,Jc=8190003,Zc=8190004,Qc=99e5,eu=9900001,tu=9900002,nu=9900003,ru=9900004;function Cr(s){return Array.isArray(s)?"%5B"+s.map(Cr).join("%2C%20")+"%5D":typeof s=="bigint"?`${s}n`:encodeURIComponent(String(s!=null&&Object.getPrototypeOf(s)===null?w({},s):s))}function su([s,e]){return`${s}=${Cr(e)}`}function ou(s){let e=Object.entries(s).map(su).join("&");return btoa(e)}var Nl={[jo]:"Account not found at address: $address",[Zo]:"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",[Jo]:"Expected decoded account at address: $address",[Xo]:"Failed to decode account data at address: $address",[Yo]:"Accounts not found at addresses: $addresses",[Go]:"Unable to find a viable program address bump seed.",[Mo]:"$putativeAddress is not a base58-encoded address.",[Do]:"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",[zo]:"The `CryptoKey` must be an `Ed25519` public key.",[qo]:"$putativeOffCurveAddress is not a base58-encoded off-curve address.",[Vo]:"Invalid seeds; point must fall off the Ed25519 curve.",[Ko]:"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",[Fo]:"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",[$o]:"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",[Wo]:"Expected program derived address bump to be in the range [0, 255], got: $bump.",[Ho]:"Program address cannot end with PDA marker.",[Uo]:"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",[ao]:"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",[so]:"The network has progressed past the last block for which this transaction could have been committed.",[dn]:"Codec [$codecDescription] cannot decode empty byte arrays.",[$c]:"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",[Tr]:"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",[hn]:"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",[_n]:"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",[fn]:"Encoder and decoder must either both be fixed-size or variable-size.",[Bc]:"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",[Ir]:"Expected a fixed-size codec, got a variable-size one.",[Nr]:"Codec [$codecDescription] expected a positive byte length, got $bytesLength.",[Or]:"Expected a variable-size codec, got a fixed-size one.",[Fc]:"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",[ln]:"Codec [$codecDescription] expected $expected bytes, got $bytesLength.",[Wc]:"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",[xc]:"Invalid discriminated union variant. Expected one of [$variants], got $value.",[Dc]:"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",[Mc]:"Invalid literal union variant. Expected one of [$variants], got $value.",[Pc]:"Expected [$codecDescription] to have $expected items, got $actual.",[Uc]:"Invalid value $value for base $base with alphabet $alphabet.",[zc]:"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",[gn]:"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",[wr]:"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",[kr]:"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",[Kc]:"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",[ai]:"No random values implementation could be found.",[Oi]:"instruction requires an uninitialized account",[zi]:"instruction tries to borrow reference for an account which is already borrowed",[Ki]:"instruction left account with an outstanding borrowed reference",[Ui]:"program other than the account's owner changed the size of the account data",[Si]:"account data too small for instruction",[Mi]:"instruction expected an executable account",[ca]:"An account does not have enough lamports to be rent-exempt",[da]:"Program arithmetic overflowed",[aa]:"Failed to serialize or deserialize account data: $encodedData",[pa]:"Builtin programs must consume compute units",[ji]:"Cross-program invocation call depth too deep",[ea]:"Computational budget exceeded",[Fi]:"custom program error: #$code",[Pi]:"instruction contains duplicate accounts",[Wi]:"instruction modifications of multiply-passed account differ",[Hi]:"executable accounts must be rent exempt",[Vi]:"instruction changed executable accounts data",[Gi]:"instruction changed the balance of an executable account",[Bi]:"instruction changed executable bit of an account",[Ci]:"instruction modified data of an account it does not own",[ki]:"instruction spent from the balance of an account it does not own",[mi]:"generic instruction error",[fa]:"Provided owner is not allowed",[oa]:"Account is immutable",[ia]:"Incorrect authority provided",[bi]:"incorrect program id for instruction",[Ei]:"insufficient funds for instruction",[Ai]:"invalid account data for instruction",[ua]:"Invalid account owner",[yi]:"invalid program argument",[$i]:"program returned invalid error code",[Ri]:"invalid instruction data",[Qi]:"Failed to reallocate account data",[Zi]:"Provided seeds do not result in a valid address",[ha]:"Accounts data allocations exceeded the maximum allowed per transaction",[_a]:"Max accounts exceeded",[ga]:"Max instruction trace length exceeded",[Ji]:"Length of the seed is too long for address generation",[Yi]:"An account required by the instruction is missing",[Ii]:"missing required signature for instruction",[Ti]:"instruction illegally modified the program id of an account",[Di]:"insufficient account keys for instruction",[ta]:"Cross-program invocation with unauthorized signer or writable account",[na]:"Failed to create program execution environment",[sa]:"Program failed to compile",[ra]:"Program failed to complete",[vi]:"instruction modified data of a read-only account",[Li]:"instruction changed the balance of a read-only account",[Xi]:"Cross-program invocation reentrancy not allowed for this instruction",[xi]:"instruction modified rent epoch of an account",[wi]:"sum of account balances before and after instruction do not match",[Ni]:"instruction requires an initialized account",[pi]:"",[qi]:"Unsupported program id",[la]:"Unsupported sysvar",[hi]:"The instruction does not have any accounts.",[_i]:"The instruction does not have any data.",[gi]:"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",[co]:"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",[oo]:"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",[tu]:"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[ru]:"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",[eu]:"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[Qc]:"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[nu]:"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",[po]:"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",[mo]:"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",[Ro]:"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",[yo]:"JSON-RPC error: The method does not exist / is not available ($__serverMessage)",[go]:"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",[Io]:"$__serverMessage",[xo]:"$__serverMessage",[vo]:"$__serverMessage",[Eo]:"$__serverMessage",[No]:"$__serverMessage",[wo]:"$__serverMessage",[Ao]:"Minimum context slot has not been reached",[Lo]:"Node is unhealthy; behind by $numSlotsBehind slots",[To]:"No snapshot",[Bo]:"Transaction simulation failed",[ko]:"$__serverMessage",[Oo]:"Transaction history is not available from this node",[Co]:"$__serverMessage",[bo]:"Transaction signature length mismatch",[Po]:"Transaction signature verification failure",[So]:"$__serverMessage",[ci]:"Key pair bytes must be of length 64, got $byteLength.",[ui]:"Expected private key bytes with length 32. Actual length: $actualLength.",[di]:"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",[fi]:"The provided private key does not match the provided public key.",[li]:"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",[uo]:"Lamports value must be in the range [0, 2e64-1]",[lo]:"`$value` cannot be parsed as a `BigInt`",[_o]:"$message",[fo]:"`$value` cannot be parsed as a `Number`",[io]:"No nonce account could be found at address `$nonceAccountAddress`",[jc]:"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",[Xc]:"WebSocket was closed before payload could be added to the send buffer",[Jc]:"WebSocket connection closed",[Zc]:"WebSocket failed to connect",[Yc]:"Failed to obtain a subscription id from the server",[qc]:"Could not find an API plan for RPC method: `$method`",[Vc]:"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",[Hc]:"HTTP error ($statusCode): $message",[Gc]:"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",[ma]:"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",[ya]:"The provided value does not implement the `KeyPairSigner` interface",[Aa]:"The provided value does not implement the `MessageModifyingSigner` interface",[Sa]:"The provided value does not implement the `MessagePartialSigner` interface",[Ra]:"The provided value does not implement any of the `MessageSigner` interfaces",[ba]:"The provided value does not implement the `TransactionModifyingSigner` interface",[Ia]:"The provided value does not implement the `TransactionPartialSigner` interface",[Oa]:"The provided value does not implement the `TransactionSendingSigner` interface",[Ea]:"The provided value does not implement any of the `TransactionSigner` interfaces",[Na]:"More than one `TransactionSendingSigner` was identified.",[wa]:"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",[Ta]:"Wallet account signers do not support signing multiple messages/transactions in a single operation",[ii]:"Cannot export a non-extractable key.",[ei]:"No digest implementation could be found.",[Qo]:"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",[ti]:`This runtime does not support the generation of Ed25519 key pairs.

Install @solana/webcrypto-ed25519-polyfill and call its \`install\` function before generating keys in environments that do not support Ed25519.

For a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.`,[ni]:"No signature verification implementation could be found.",[ri]:"No key generation implementation could be found.",[si]:"No signing implementation could be found.",[oi]:"No key export implementation could be found.",[ho]:"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",[fc]:"Transaction processing left an account with an outstanding borrowed reference",[Ja]:"Account in use",[Za]:"Account loaded twice",[Qa]:"Attempt to debit an account but found no record of a prior credit.",[Rc]:"Transaction loads an address table account that doesn't exist",[rc]:"This transaction has already been processed",[sc]:"Blockhash not found",[oc]:"Loader call chain is too deep",[lc]:"Transactions are currently disabled due to cluster maintenance",[Nc]:"Transaction contains a duplicate instruction ($index) that is not allowed",[tc]:"Insufficient funds for fee",[wc]:"Transaction results in an account ($accountIndex) with insufficient funds for rent",[nc]:"This account may not be used to pay transaction fees",[ac]:"Transaction contains an invalid account reference",[Sc]:"Transaction loads an address table account with invalid data",[Ec]:"Transaction address table lookup uses an invalid index",[Ac]:"Transaction loads an address table account with an invalid owner",[kc]:"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",[uc]:"This program may not be used for executing instructions",[bc]:"Transaction leaves an account with a lower balance than rent-exempt minimum",[gc]:"Transaction loads a writable account that cannot be written",[Tc]:"Transaction exceeded max loaded accounts data size cap",[ic]:"Transaction requires a fee but has no signature present",[ec]:"Attempt to load a program that does not exist",[Lc]:"Execution of the program referenced by account at index $accountIndex is temporarily restricted.",[Cc]:"ResanitizationNeeded",[dc]:"Transaction failed to sanitize accounts offsets correctly",[cc]:"Transaction did not pass signature verification",[yc]:"Transaction locked too many accounts",[vc]:"Sum of account balances before and after transaction do not match",[Xa]:"The transaction failed with the error `$errorName`",[_c]:"Transaction version is unsupported",[mc]:"Transaction would exceed account data limit within the block",[Oc]:"Transaction would exceed total account data limit",[pc]:"Transaction would exceed max account limit within the block",[hc]:"Transaction would exceed max Block Cost Limit",[Ic]:"Transaction would exceed max Vote Cost Limit",[Va]:"Attempted to sign a transaction with an address that is not a signer for it",[za]:"Transaction is missing an address at index: $index.",[Ga]:"Transaction has no expected signers therefore it cannot be encoded",[Ya]:"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",[La]:"Transaction does not have a blockhash lifetime",[va]:"Transaction is not a durable nonce transaction",[Ba]:"Contents of these address lookup tables unknown: $lookupTableAddresses",[xa]:"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",[Ua]:"No fee payer set in CompiledTransaction",[Da]:"Could not find program address at index $index",[qa]:"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",[ja]:"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",[Ka]:"Transaction is missing a fee payer.",[Wa]:"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",[$a]:"Transaction first instruction is not advance nonce account instruction.",[Fa]:"Transaction with no instructions cannot be durable nonce transaction.",[ka]:"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",[Ca]:"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",[Ha]:"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",[Ma]:"Transaction is missing signatures for addresses: $addresses.",[Pa]:"Transaction version must be in the range [0, 127]. `$actualVersion` given"};function iu(s,e={}){{let t=`Solana error #${s}; Decode this error by running \`npx @solana/errors decode -- ${s}`;return Object.keys(e).length&&(t+=` '${ou(e)}'`),`${t}\``}}var Re=class extends Error{cause=this.cause;context;constructor(...[s,e]){let t,n;if(e){let o=e,{cause:i}=o,a=le(o,["cause"]);i&&(n={cause:i}),Object.keys(a).length>0&&(t=a)}let r=iu(s,t);super(r,n),this.context=w({__code:s},t),this.name="SolanaError"}};function au(s,e){return"fixedSize"in e?e.fixedSize:e.getSizeFromValue(s)}function Lr(s){return Object.freeze(L(w({},s),{encode:e=>{let t=new Uint8Array(au(e,s));return s.write(e,t,0),t}}))}function vr(s){return Object.freeze(L(w({},s),{decode:(e,t=0)=>s.read(e,t)[0]}))}function Fe(s){return"fixedSize"in s&&typeof s.fixedSize=="number"}function Pr(s,e){if(Fe(s)!==Fe(e))throw new Re(fn);if(Fe(s)&&Fe(e)&&s.fixedSize!==e.fixedSize)throw new Re(hn,{decoderFixedSize:e.fixedSize,encoderFixedSize:s.fixedSize});if(!Fe(s)&&!Fe(e)&&s.maxSize!==e.maxSize)throw new Re(_n,{decoderMaxSize:e.maxSize,encoderMaxSize:s.maxSize});return L(w(w({},e),s),{decode:e.decode,encode:s.encode,read:e.read,write:s.write})}function Br(s,e,t=0){if(e.length-t<=0)throw new Re(dn,{codecDescription:s})}function xr(s,e,t,n=0){let r=t.length-n;if(r<e)throw new Re(ln,{bytesLength:r,codecDescription:s,expected:e})}function cu(s,e,t,n){if(n<e||n>t)throw new Re(gn,{codecDescription:s,max:t,min:e,value:n})}function Dr(s){return s?.endian!==1}function uu(s){return Lr({fixedSize:s.size,write(e,t,n){s.range&&cu(s.name,s.range[0],s.range[1],e);let r=new ArrayBuffer(s.size);return s.set(new DataView(r),e,Dr(s.config)),t.set(new Uint8Array(r),n),n+s.size}})}function du(s){return vr({fixedSize:s.size,read(e,t=0){Br(s.name,e,t),xr(s.name,s.size,e,t);let n=new DataView(lu(e,t,s.size));return[s.get(n,Dr(s.config)),t+s.size]}})}function lu(s,e,t){let n=s.byteOffset+(e??0),r=t??s.byteLength;return s.buffer.slice(n,n+r)}var pn=(s={})=>uu({config:s,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(e,t,n)=>e.setBigUint64(0,BigInt(t),n),size:8}),fu=(s={})=>du({config:s,get:(e,t)=>e.getBigUint64(0,t),name:"u64",size:8}),Ur=(s={})=>Pr(pn(s),fu(s));var mn=class extends TypeError{constructor(e,t){let n,l=e,{message:r,explanation:o}=l,i=le(l,["message","explanation"]),{path:a}=e,c=a.length===0?r:`At path: ${a.join(".")} -- ${r}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}};function hu(s){return tt(s)&&typeof s[Symbol.iterator]=="function"}function tt(s){return typeof s=="object"&&s!=null}function wt(s){return tt(s)&&!Array.isArray(s)}function ie(s){return typeof s=="symbol"?s.toString():typeof s=="string"?JSON.stringify(s):`${s}`}function _u(s){let{done:e,value:t}=s.next();return e?void 0:t}function gu(s,e,t,n){if(s===!0)return;s===!1?s={}:typeof s=="string"&&(s={message:s});let{path:r,branch:o}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${ie(n)}\``}=s;return L(w({value:n,type:i,refinement:a,key:r[r.length-1],path:r,branch:o},s),{message:c})}function*Mr(s,e,t,n){hu(s)||(s=[s]);for(let r of s){let o=gu(r,e,t,n);o&&(yield o)}}function*yn(s,e,t={}){let{path:n=[],branch:r=[s],coerce:o=!1,mask:i=!1}=t,a={path:n,branch:r,mask:i};o&&(s=e.coercer(s,a));let c="valid";for(let l of e.validator(s,a))l.explanation=t.message,c="not_valid",yield[l,void 0];for(let[l,h,m]of e.entries(s,a)){let N=yn(h,m,{path:l===void 0?n:[...n,l],branch:l===void 0?r:[...r,h],coerce:o,mask:i,message:t.message});for(let E of N)E[0]?(c=E[0].refinement!=null?"not_refined":"not_valid",yield[E[0],void 0]):o&&(h=E[1],l===void 0?s=h:s instanceof Map?s.set(l,h):s instanceof Set?s.add(h):tt(s)&&(h!==void 0||l in s)&&(s[l]=h))}if(c!=="not_valid")for(let l of e.refiner(s,a))l.explanation=t.message,c="not_refined",yield[l,void 0];c==="valid"&&(yield[void 0,s])}var re=class{constructor(e){let{type:t,schema:n,validator:r,refiner:o,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,r?this.validator=(c,l)=>{let h=r(c,l);return Mr(h,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{let h=o(c,l);return Mr(h,l,this,c)}:this.refiner=()=>[]}assert(e,t){return zr(e,this,t)}create(e,t){return y(e,this,t)}is(e){return Kr(e,this)}mask(e,t){return pu(e,this,t)}validate(e,t={}){return nt(e,this,t)}};function zr(s,e,t){let n=nt(s,e,{message:t});if(n[0])throw n[0]}function y(s,e,t){let n=nt(s,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function pu(s,e,t){let n=nt(s,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Kr(s,e){return!nt(s,e)[0]}function nt(s,e,t={}){let n=yn(s,e,t),r=_u(n);return r[0]?[new mn(r[0],function*(){for(let i of n)i[0]&&(yield i[0])}),void 0]:[void 0,r[1]]}function Le(s,e){return new re({type:s,schema:null,validator:e})}function Wr(){return Le("any",()=>!0)}function A(s){return new re({type:"array",schema:s,*entries(e){if(s&&Array.isArray(e))for(let[t,n]of e.entries())yield[t,n,s]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${ie(e)}`}})}function ae(){return Le("boolean",s=>typeof s=="boolean")}function Tt(s){return Le("instance",e=>e instanceof s||`Expected a \`${s.name}\` instance, but received: ${ie(e)}`)}function F(s){let e=ie(s),t=typeof s;return new re({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?s:null,validator(n){return n===s||`Expected the literal \`${e}\`, but received: ${ie(n)}`}})}function mu(){return Le("never",()=>!1)}function S(s){return new re(L(w({},s),{validator:(e,t)=>e===null||s.validator(e,t),refiner:(e,t)=>e===null||s.refiner(e,t)}))}function f(){return Le("number",s=>typeof s=="number"&&!isNaN(s)||`Expected a number, but received: ${ie(s)}`)}function T(s){return new re(L(w({},s),{validator:(e,t)=>e===void 0||s.validator(e,t),refiner:(e,t)=>e===void 0||s.refiner(e,t)}))}function Rn(s,e){return new re({type:"record",schema:null,*entries(t){if(tt(t))for(let n in t){let r=t[n];yield[n,n,s],yield[n,r,e]}},validator(t){return wt(t)||`Expected an object, but received: ${ie(t)}`},coercer(t){return wt(t)?w({},t):t}})}function p(){return Le("string",s=>typeof s=="string"||`Expected a string, but received: ${ie(s)}`)}function kt(s){let e=mu();return new re({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){let n=Math.max(s.length,t.length);for(let r=0;r<n;r++)yield[r,t[r],s[r]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${ie(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function _(s){let e=Object.keys(s);return new re({type:"type",schema:s,*entries(t){if(tt(t))for(let n of e)yield[n,t[n],s[n]]},validator(t){return wt(t)||`Expected an object, but received: ${ie(t)}`},coercer(t){return wt(t)?w({},t):t}})}function Y(s){let e=s.map(t=>t.type).join(" | ");return new re({type:"union",schema:null,coercer(t,n){for(let r of s){let[o,i]=r.validate(t,{coerce:!0,mask:n.mask});if(!o)return i}return t},validator(t,n){let r=[];for(let o of s){let[...i]=yn(t,o,n),[a]=i;if(a[0])for(let[c]of i)c&&r.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${ie(t)}`,...r]}})}function ve(){return Le("unknown",()=>!0)}function $e(s,e,t){return new re(L(w({},s),{coercer:(n,r)=>Kr(n,e)?s.coercer(t(n,r),r):s.coercer(n,r)}))}var is=oe(eo());to();Hs();Ys();var Hl=Ce.utils.randomPrivateKey,Fr=()=>{let s=Ce.utils.randomPrivateKey(),e=kn(s),t=new Uint8Array(64);return t.set(s),t.set(e,32),{publicKey:e,secretKey:t}},kn=Ce.getPublicKey;function $r(s){try{return Ce.ExtendedPoint.fromHex(s),!0}catch{return!1}}var Wn=(s,e)=>Ce.sign(s,e.slice(0,32)),yu=Ce.verify,x=s=>k.Buffer.isBuffer(s)?s:s instanceof Uint8Array?k.Buffer.from(s.buffer,s.byteOffset,s.byteLength):k.Buffer.from(s),Cn=class{constructor(e){Object.assign(this,e)}encode(){return k.Buffer.from((0,Ye.serialize)(vt,this))}static decode(e){return(0,Ye.deserialize)(vt,this,e)}static decodeUnchecked(e){return(0,Ye.deserializeUnchecked)(vt,this,e)}};var vt=new Map,as,Ru=32,Ee=32;function Au(s){return s._bn!==void 0}var Vr=1,b=class s extends Cn{constructor(e){if(super({}),this._bn=void 0,Au(e))this._bn=e._bn;else{if(typeof e=="string"){let t=j.default.decode(e);if(t.length!=Ee)throw new Error("Invalid public key input");this._bn=new Tn.default(t)}else this._bn=new Tn.default(e);if(this._bn.byteLength()>Ee)throw new Error("Invalid public key input")}}static unique(){let e=new s(Vr);return Vr+=1,new s(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return j.default.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){let e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){let e=this._bn.toArrayLike(k.Buffer);if(e.length===Ee)return e;let t=k.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static createWithSeed(e,t,n){return d(this,null,function*(){let r=k.Buffer.concat([e.toBuffer(),k.Buffer.from(t),n.toBuffer()]),o=un(r);return new s(o)})}static createProgramAddressSync(e,t){let n=k.Buffer.alloc(0);e.forEach(function(o){if(o.length>Ru)throw new TypeError("Max seed length exceeded");n=k.Buffer.concat([n,x(o)])}),n=k.Buffer.concat([n,t.toBuffer(),k.Buffer.from("ProgramDerivedAddress")]);let r=un(n);if($r(r))throw new Error("Invalid seeds, address must fall off the curve");return new s(r)}static createProgramAddress(e,t){return d(this,null,function*(){return this.createProgramAddressSync(e,t)})}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{let o=e.concat(k.Buffer.from([n]));r=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static findProgramAddress(e,t){return d(this,null,function*(){return this.findProgramAddressSync(e,t)})}static isOnCurve(e){let t=new s(e);return $r(t.toBytes())}};as=b;b.default=new as("11111111111111111111111111111111");vt.set(b,{kind:"struct",fields:[["_bn","u256"]]});var ql=new b("BPFLoader1111111111111111111111111111111111"),Be=1232,Fn=127,Pt=64,Bt=class extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}};Object.defineProperty(Bt.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});var xt=class extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}};Object.defineProperty(xt.prototype,"name",{value:"TransactionExpiredTimeoutError"});var Pe=class extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}};Object.defineProperty(Pe.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});var He=class{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){let e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(let t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");let n=new Map;this.keySegments().flat().forEach((o,i)=>{n.set(o.toBase58(),i)});let r=o=>{let i=n.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(o=>({programIdIndex:r(o.programId),accountKeyIndexes:o.keys.map(i=>r(i.pubkey)),data:o.data}))}},P=(s="publicKey")=>u.blob(32,s),Su=(s="signature")=>u.blob(64,s),Ge=(s="string")=>{let e=u.struct([u.u32("length"),u.u32("lengthPadding"),u.blob(u.offset(u.u32(),-8),"chars")],s),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(o,i)=>t(o,i).chars.toString(),r.encode=(o,i,a)=>{let c={chars:k.Buffer.from(o,"utf8")};return n(c,i,a)},r.alloc=o=>u.u32().span+u.u32().span+k.Buffer.from(o,"utf8").length,r},Eu=(s="authorized")=>u.struct([P("staker"),P("withdrawer")],s),bu=(s="lockup")=>u.struct([u.ns64("unixTimestamp"),u.ns64("epoch"),P("custodian")],s),Iu=(s="voteInit")=>u.struct([P("nodePubkey"),P("authorizedVoter"),P("authorizedWithdrawer"),u.u8("commission")],s),Ou=(s="voteAuthorizeWithSeedArgs")=>u.struct([u.u32("voteAuthorizationType"),P("currentAuthorityDerivedKeyOwnerPubkey"),Ge("currentAuthorityDerivedKeySeed"),P("newAuthorized")],s);function cs(s,e){let t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){let o=e[r.property];if(Array.isArray(o))return o.length*t(r.elementLayout)}else if("fields"in r)return cs({layout:r},e[r.property]);return 0},n=0;return s.layout.fields.forEach(r=>{n+=t(r)}),n}function ee(s){let e=0,t=0;for(;;){let n=s.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function te(s,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){s.push(n);break}else n|=128,s.push(n)}}function M(s,e){if(!s)throw new Error(e||"Assertion failed")}var Dt=class s{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){let n=new Map,r=i=>{let a=i.toBase58(),c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=r(t);o.isSigner=!0,o.isWritable=!0;for(let i of e){r(i.programId).isInvoked=!0;for(let a of i.keys){let c=r(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new s(t,n)}getMessageComponents(){let e=[...this.keyMetaMap.entries()];M(e.length<=256,"Max static account keys length exceeded");let t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),r=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{M(t.length>0,"Expected at least one writable signer key");let[c]=t[0];M(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}let a=[...t.map(([c])=>new b(c)),...n.map(([c])=>new b(c)),...r.map(([c])=>new b(c)),...o.map(([c])=>new b(c))];return[i,a]}extractTableLookup(e){let[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[r,o]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(e,t){let n=new Array,r=new Array;for(let[o,i]of this.keyMetaMap.entries())if(t(i)){let a=new b(o),c=e.findIndex(l=>l.equals(a));c>=0&&(M(c<256,"Max lookup table index exceeded"),n.push(c),r.push(a),this.keyMetaMap.delete(o))}return[n,r]}},us="Reached end of buffer unexpectedly";function he(s){if(s.length===0)throw new Error(us);return s.shift()}function ne(s,...e){let[t]=e;if(e.length===2?t+(e[1]??0)>s.length:t>=s.length)throw new Error(us);return s.splice(...e)}var be=class s{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new b(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:j.default.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new He(this.staticAccountKeys)}static compile(e){let t=Dt.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new He(r).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:j.default.encode(a.data)}));return new s({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){let n=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<o}else{let n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){let e=this.accountKeys.length,t=[];te(t,e);let n=this.instructions.map(m=>{let{accounts:N,programIdIndex:E}=m,R=Array.from(j.default.decode(m.data)),g=[];te(g,N.length);let I=[];return te(I,R.length),{programIdIndex:E,keyIndicesCount:k.Buffer.from(g),keyIndices:N,dataLength:k.Buffer.from(I),data:R}}),r=[];te(r,n.length);let o=k.Buffer.alloc(Be);k.Buffer.from(r).copy(o);let i=r.length;n.forEach(m=>{let E=u.struct([u.u8("programIdIndex"),u.blob(m.keyIndicesCount.length,"keyIndicesCount"),u.seq(u.u8("keyIndex"),m.keyIndices.length,"keyIndices"),u.blob(m.dataLength.length,"dataLength"),u.seq(u.u8("userdatum"),m.data.length,"data")]).encode(m,o,i);i+=E}),o=o.slice(0,i);let a=u.struct([u.blob(1,"numRequiredSignatures"),u.blob(1,"numReadonlySignedAccounts"),u.blob(1,"numReadonlyUnsignedAccounts"),u.blob(t.length,"keyCount"),u.seq(P("key"),e,"keys"),P("recentBlockhash")]),c={numRequiredSignatures:k.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:k.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:k.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:k.Buffer.from(t),keys:this.accountKeys.map(m=>x(m.toBytes())),recentBlockhash:j.default.decode(this.recentBlockhash)},l=k.Buffer.alloc(2048),h=a.encode(c,l);return o.copy(l,h),l.slice(0,h+o.length)}static from(e){let t=[...e],n=he(t);if(n!==(n&Fn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");let r=he(t),o=he(t),i=ee(t),a=[];for(let N=0;N<i;N++){let E=ne(t,0,Ee);a.push(new b(k.Buffer.from(E)))}let c=ne(t,0,Ee),l=ee(t),h=[];for(let N=0;N<l;N++){let E=he(t),R=ee(t),g=ne(t,0,R),I=ee(t),C=ne(t,0,I),z=j.default.encode(k.Buffer.from(C));h.push({programIdIndex:E,accounts:g,data:z})}let m={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:o},recentBlockhash:j.default.encode(k.Buffer.from(c)),accountKeys:a,instructions:h};return new s(m)}},Ut=class s{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(let t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new He(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){let t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){let r=e-n,o=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return r<o}else if(e>=this.header.numRequiredSignatures){let r=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return r<i}else{let r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){let t={writable:[],readonly:[]};for(let n of this.addressTableLookups){let r=e.find(o=>o.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(let o of n.writableIndexes)if(o<r.state.addresses.length)t.writable.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(let o of n.readonlyIndexes)if(o<r.state.addresses.length)t.readonly.push(r.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){let t=Dt.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(let h of o){let m=t.extractTableLookup(h);if(m!==void 0){let[N,{writable:E,readonly:R}]=m;n.push(N),r.writable.push(...E),r.readonly.push(...R)}}let[i,a]=t.getMessageComponents(),l=new He(a,r).compileInstructions(e.instructions);return new s({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:n})}serialize(){let e=Array();te(e,this.staticAccountKeys.length);let t=this.serializeInstructions(),n=Array();te(n,this.compiledInstructions.length);let r=this.serializeAddressTableLookups(),o=Array();te(o,this.addressTableLookups.length);let i=u.struct([u.u8("prefix"),u.struct([u.u8("numRequiredSignatures"),u.u8("numReadonlySignedAccounts"),u.u8("numReadonlyUnsignedAccounts")],"header"),u.blob(e.length,"staticAccountKeysLength"),u.seq(P(),this.staticAccountKeys.length,"staticAccountKeys"),P("recentBlockhash"),u.blob(n.length,"instructionsLength"),u.blob(t.length,"serializedInstructions"),u.blob(o.length,"addressTableLookupsLength"),u.blob(r.length,"serializedAddressTableLookups")]),a=new Uint8Array(Be),l=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(h=>h.toBytes()),recentBlockhash:j.default.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:r},a);return a.slice(0,l)}serializeInstructions(){let e=0,t=new Uint8Array(Be);for(let n of this.compiledInstructions){let r=Array();te(r,n.accountKeyIndexes.length);let o=Array();te(o,n.data.length);let i=u.struct([u.u8("programIdIndex"),u.blob(r.length,"encodedAccountKeyIndexesLength"),u.seq(u.u8(),n.accountKeyIndexes.length,"accountKeyIndexes"),u.blob(o.length,"encodedDataLength"),u.blob(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0,t=new Uint8Array(Be);for(let n of this.addressTableLookups){let r=Array();te(r,n.writableIndexes.length);let o=Array();te(o,n.readonlyIndexes.length);let i=u.struct([P("accountKey"),u.blob(r.length,"encodedWritableIndexesLength"),u.seq(u.u8(),n.writableIndexes.length,"writableIndexes"),u.blob(o.length,"encodedReadonlyIndexesLength"),u.seq(u.u8(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e],n=he(t),r=n&Fn;M(n!==r,"Expected versioned message but received legacy message");let o=r;M(o===0,`Expected versioned message with version 0 but found version ${o}`);let i={numRequiredSignatures:he(t),numReadonlySignedAccounts:he(t),numReadonlyUnsignedAccounts:he(t)},a=[],c=ee(t);for(let R=0;R<c;R++)a.push(new b(ne(t,0,Ee)));let l=j.default.encode(ne(t,0,Ee)),h=ee(t),m=[];for(let R=0;R<h;R++){let g=he(t),I=ee(t),C=ne(t,0,I),z=ee(t),V=new Uint8Array(ne(t,0,z));m.push({programIdIndex:g,accountKeyIndexes:C,data:V})}let N=ee(t),E=[];for(let R=0;R<N;R++){let g=new b(ne(t,0,Ee)),I=ee(t),C=ne(t,0,I),z=ee(t),V=ne(t,0,z);E.push({accountKey:g,writableIndexes:C,readonlyIndexes:V})}return new s({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:m,addressTableLookups:E})}},ds={deserializeMessageVersion(s){let e=s[0],t=e&Fn;return t===e?"legacy":t},deserialize:s=>{let e=ds.deserializeMessageVersion(s);if(e==="legacy")return be.from(s);if(e===0)return Ut.deserialize(s);throw new Error(`Transaction message version ${e} deserialization is not supported`)}},Ae=function(s){return s[s.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",s[s.PROCESSED=1]="PROCESSED",s[s.TIMED_OUT=2]="TIMED_OUT",s[s.NONCE_INVALID=3]="NONCE_INVALID",s}({}),Nu=k.Buffer.alloc(Pt).fill(0),U=class{constructor(e){this.keys=void 0,this.programId=void 0,this.data=k.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}},B=class s{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){let{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){let{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{let{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new U(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let g=0;g<t.length;g++)if(t[g].programId===void 0)throw new Error(`Transaction instruction index ${g} has undefined program id`);let r=[],o=[];t.forEach(g=>{g.keys.forEach(C=>{o.push(w({},C))});let I=g.programId.toString();r.includes(I)||r.push(I)}),r.forEach(g=>{o.push({pubkey:new b(g),isSigner:!1,isWritable:!1})});let i=[];o.forEach(g=>{let I=g.pubkey.toString(),C=i.findIndex(z=>z.pubkey.toString()===I);C>-1?(i[C].isWritable=i[C].isWritable||g.isWritable,i[C].isSigner=i[C].isSigner||g.isSigner):i.push(g)}),i.sort(function(g,I){if(g.isSigner!==I.isSigner)return g.isSigner?-1:1;if(g.isWritable!==I.isWritable)return g.isWritable?-1:1;let C={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return g.pubkey.toBase58().localeCompare(I.pubkey.toBase58(),"en",C)});let a=i.findIndex(g=>g.pubkey.equals(n));if(a>-1){let[g]=i.splice(a,1);g.isSigner=!0,g.isWritable=!0,i.unshift(g)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(let g of this.signatures){let I=i.findIndex(C=>C.pubkey.equals(g.publicKey));if(I>-1)i[I].isSigner||(i[I].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${g.publicKey.toString()}`)}let c=0,l=0,h=0,m=[],N=[];i.forEach(({pubkey:g,isSigner:I,isWritable:C})=>{I?(m.push(g.toString()),c+=1,C||(l+=1)):(N.push(g.toString()),C||(h+=1))});let E=m.concat(N),R=t.map(g=>{let{data:I,programId:C}=g;return{programIdIndex:E.indexOf(C.toString()),accounts:g.keys.map(z=>E.indexOf(z.pubkey.toString())),data:j.default.encode(I)}});return R.forEach(g=>{M(g.programIdIndex>=0),g.accounts.forEach(I=>M(I>=0))}),new be({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:h},accountKeys:E,recentBlockhash:e,instructions:R})}_compile(){let e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,o)=>t[o].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}getEstimatedFee(e){return d(this,null,function*(){return(yield e.getFeeForMessage(this.compileMessage())).value})}setSigners(...e){if(e.length===0)throw new Error("No signers");let t=new Set;this.signatures=e.filter(n=>{let r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));let r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");let t=new Set,n=[];for(let o of e){let i=o.publicKey.toString();t.has(i)||(t.add(i),n.push(o))}let r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){let n=e.serialize();t.forEach(r=>{let o=Wn(n,r.secretKey);this._addSignature(r.publicKey,x(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){M(t.length===64);let n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=k.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){let n={};for(let{signature:r,publicKey:o}of this.signatures)r===null?t&&(n.missing||=[]).push(o):yu(r,e,o.toBytes())||(n.invalid||=[]).push(o);return n.invalid||n.missing?n:void 0}serialize(e){let{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){let o=this._getMessageSignednessErrors(r,t);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(r)}_serialize(e){let{signatures:t}=this,n=[];te(n,t.length);let r=n.length+t.length*64+e.length,o=k.Buffer.alloc(r);return M(t.length<256),k.Buffer.from(n).copy(o,0),t.forEach(({signature:i},a)=>{i!==null&&(M(i.length===64,"signature has invalid length"),k.Buffer.from(i).copy(o,n.length+a*64))}),e.copy(o,n.length+t.length*64),M(o.length<=Be,`Transaction too large: ${o.length} > ${Be}`),o}get keys(){return M(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return M(this.instructions.length===1),this.instructions[0].programId}get data(){return M(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e],n=ee(t),r=[];for(let o=0;o<n;o++){let i=ne(t,0,Pt);r.push(j.default.encode(k.Buffer.from(i)))}return s.populate(be.from(t),r)}static populate(e,t=[]){let n=new s;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,o)=>{let i={signature:r==j.default.encode(Nu)?null:j.default.decode(r),publicKey:e.accountKeys[o]};n.signatures.push(i)}),e.instructions.forEach(r=>{let o=r.accounts.map(i=>{let a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new U({keys:o,programId:e.accountKeys[r.programIdIndex],data:j.default.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}};var ce=class s{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)M(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{let n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(Pt));this.signatures=n}this.message=e}serialize(){let e=this.message.serialize(),t=Array();te(t,this.signatures.length);let n=u.struct([u.blob(t.length,"encodedSignaturesLength"),u.seq(Su(),this.signatures.length,"signatures"),u.blob(e.length,"serializedMessage")]),r=new Uint8Array(2048),o=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,o)}static deserialize(e){let t=[...e],n=[],r=ee(t);for(let i=0;i<r;i++)n.push(new Uint8Array(ne(t,0,Pt)));let o=ds.deserialize(new Uint8Array(t));return new s(o,n)}sign(e){let t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(let r of e){let o=n.findIndex(i=>i.equals(r.publicKey));M(o>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[o]=Wn(t,r.secretKey)}}addSignature(e,t){M(t.byteLength===64,"Signature must be 64 bytes long");let r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(o=>o.equals(e));M(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}},wu=160,Tu=64,ku=wu/Tu,Cu=1e3/ku,fe=new b("SysvarC1ock11111111111111111111111111111111"),jl=new b("SysvarEpochSchedu1e111111111111111111111111"),Yl=new b("Sysvar1nstructions1111111111111111111111111"),An=new b("SysvarRecentB1ockHashes11111111111111111111"),Mt=new b("SysvarRent111111111111111111111111111111111"),Xl=new b("SysvarRewards111111111111111111111111111111"),Jl=new b("SysvarS1otHashes111111111111111111111111111"),Zl=new b("SysvarS1otHistory11111111111111111111111111"),Sn=new b("SysvarStakeHistory1111111111111111111111111"),qe=class extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){let o=r?`Logs: 
${JSON.stringify(r.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.",a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+o+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){let e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}getLogs(e){return d(this,null,function*(){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(r=>{if(r&&r.meta&&r.meta.logMessages){let o=r.meta.logMessages;this.transactionLogs=o,t(o)}else n(new Error("Log messages not found"))}).catch(n)})),yield this.transactionLogs})}};var O=class extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}};function Ve(s){return new Promise(e=>setTimeout(e,s))}function D(s,e){let t=s.layout.span>=0?s.layout.span:cs(s,e),n=k.Buffer.alloc(t),r=Object.assign({instruction:s.index},e);return s.layout.encode(r,n),n}var Lu=u.nu64("lamportsPerSignature"),ls=u.struct([u.u32("version"),u.u32("state"),P("authorizedPubkey"),P("nonce"),u.struct([Lu],"feeCalculator")]),Gr=ls.span,Ln=class s{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){let t=ls.decode(x(e),0);return new s({authorizedPubkey:new b(t.authorizedPubkey),nonce:new b(t.nonce).toString(),feeCalculator:t.feeCalculator})}};function je(s){let e=(0,os.blob)(8,s),t=e.decode.bind(e),n=e.encode.bind(e),r=e,o=Ur();return r.decode=(i,a)=>{let c=t(i,a);return o.decode(c)},r.encode=(i,a,c)=>{let l=o.encode(i);return n(l,a,c)},r}var se=Object.freeze({Create:{index:0,layout:u.struct([u.u32("instruction"),u.ns64("lamports"),u.ns64("space"),P("programId")])},Assign:{index:1,layout:u.struct([u.u32("instruction"),P("programId")])},Transfer:{index:2,layout:u.struct([u.u32("instruction"),je("lamports")])},CreateWithSeed:{index:3,layout:u.struct([u.u32("instruction"),P("base"),Ge("seed"),u.ns64("lamports"),u.ns64("space"),P("programId")])},AdvanceNonceAccount:{index:4,layout:u.struct([u.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:u.struct([u.u32("instruction"),P("authorized")])},AuthorizeNonceAccount:{index:7,layout:u.struct([u.u32("instruction"),P("authorized")])},Allocate:{index:8,layout:u.struct([u.u32("instruction"),u.ns64("space")])},AllocateWithSeed:{index:9,layout:u.struct([u.u32("instruction"),P("base"),Ge("seed"),u.ns64("space"),P("programId")])},AssignWithSeed:{index:10,layout:u.struct([u.u32("instruction"),P("base"),Ge("seed"),P("programId")])},TransferWithSeed:{index:11,layout:u.struct([u.u32("instruction"),je("lamports"),Ge("seed"),P("programId")])},UpgradeNonceAccount:{index:12,layout:u.struct([u.u32("instruction")])}}),Z=class s{constructor(){}static createAccount(e){let t=se.Create,n=D(t,{lamports:e.lamports,space:e.space,programId:x(e.programId.toBuffer())});return new U({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){let r=se.TransferWithSeed;t=D(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:x(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{let r=se.Transfer;t=D(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new U({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){let r=se.AssignWithSeed;t=D(r,{base:x(e.basePubkey.toBuffer()),seed:e.seed,programId:x(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=se.Assign;t=D(r,{programId:x(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new U({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){let t=se.CreateWithSeed,n=D(t,{base:x(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:x(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new U({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){let t=new B;"basePubkey"in e&&"seed"in e?t.add(s.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Gr,programId:this.programId})):t.add(s.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Gr,programId:this.programId}));let n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){let t=se.InitializeNonceAccount,n=D(t,{authorized:x(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:Mt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new U(r)}static nonceAdvance(e){let t=se.AdvanceNonceAccount,n=D(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new U(r)}static nonceWithdraw(e){let t=se.WithdrawNonceAccount,n=D(t,{lamports:e.lamports});return new U({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:An,isSigner:!1,isWritable:!1},{pubkey:Mt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){let t=se.AuthorizeNonceAccount,n=D(t,{authorized:x(e.newAuthorizedPubkey.toBuffer())});return new U({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){let r=se.AllocateWithSeed;t=D(r,{base:x(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:x(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{let r=se.Allocate;t=D(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new U({keys:n,programId:this.programId,data:t})}};Z.programId=new b("11111111111111111111111111111111");var Ql=Be-300;var ef=new b("BPFLoader2111111111111111111111111111111111");function vu(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var En,Hr;function Pu(){if(Hr)return En;Hr=1;var s=Object.prototype.toString,e=Object.keys||function(n){var r=[];for(var o in n)r.push(o);return r};function t(n,r){var o,i,a,c,l,h,m;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),r);if(m=s.call(n),m==="[object Array]"){for(a="[",i=n.length-1,o=0;o<i;o++)a+=t(n[o],!0)+",";return i>-1&&(a+=t(n[o],!0)),a+"]"}else if(m==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",o=0;o<i;)l=c[o],h=t(n[l],!1),h!==void 0&&(a&&(a+=","),a+=JSON.stringify(l)+":"+h),o++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return En=function(n){var r=t(n,!1);if(r!==void 0)return""+r},En}var Bu=Pu(),qr=vu(Bu),rt=32;function bn(s){let e=0;for(;s>1;)s/=2,e++;return e}function xu(s){return s===0?1:(s--,s|=s>>1,s|=s>>2,s|=s>>4,s|=s>>8,s|=s>>16,s|=s>>32,s+1)}var vn=class{constructor(e,t,n,r,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=o}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){let t=bn(xu(e+rt+1))-bn(rt)-1,n=this.getSlotsInEpoch(t),r=e-(n-rt);return[t,r]}else{let t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,o=t%this.slotsPerEpoch;return[r,o]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*rt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+bn(rt)):this.slotsPerEpoch}},Du=globalThis.fetch,Pn=class extends Rr{constructor(e,t,n){let r=o=>{let i=yr(o,w({autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3},t));return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){let t=this.underlyingSocket?.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){let t=this.underlyingSocket?.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}};function Uu(s,e){let t;try{t=s.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==s.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${s.index}`);return t}var jr=56,zt=class{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){let e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){let t=Uu(Mu,e),n=e.length-jr;M(n>=0,"lookup table is invalid"),M(n%32===0,"lookup table is invalid");let r=n/32,{addresses:o}=u.struct([u.seq(P(),r,"addresses")]).decode(e.slice(jr));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new b(t.authority[0]):void 0,addresses:o.map(i=>new b(i))}}},Mu={index:1,layout:u.struct([u.u32("typeIndex"),je("deactivationSlot"),u.nu64("lastExtendedSlot"),u.u8("lastExtendedStartIndex"),u.u8(),u.seq(P(),u.offset(u.u8(),-1),"authority")])},zu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ku(s){let e=s.match(zu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${s}\``);let[t,n,r,o]=e,i=s.startsWith("https:")?"wss:":"ws:",a=r==null?null:parseInt(r.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${o}`}var $=$e(Tt(b),p(),s=>new b(s)),fs=kt([p(),F("base64")]),$n=$e(Tt(k.Buffer),fs,s=>k.Buffer.from(s[0],"base64")),Wu=30*1e3;function Fu(s){if(/^https?:/.test(s)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return s}function W(s){let e,t;if(typeof s=="string")e=s;else if(s){let n=s,{commitment:r}=n,o=le(n,["commitment"]);e=r,t=o}return{commitment:e,config:t}}function Yr(s){return s.map(e=>"memcmp"in e?L(w({},e),{memcmp:L(w({},e.memcmp),{encoding:e.memcmp.encoding??"base58"})}):e)}function hs(s){return Y([_({jsonrpc:F("2.0"),id:p(),result:s}),_({jsonrpc:F("2.0"),id:p(),error:_({code:ve(),message:p(),data:T(Wr())})})])}var $u=hs(ve());function v(s){return $e(hs(s),$u,e=>"error"in e?e:L(w({},e),{result:y(e.result,s)}))}function G(s){return v(_({context:_({slot:f()}),value:s}))}function $t(s){return _({context:_({slot:f()}),value:s})}function In(s,e){return s===0?new Ut({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new b(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:j.default.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new be(e)}var Vu=_({foundation:f(),foundationTerm:f(),initial:f(),taper:f(),terminal:f()}),Gu=v(A(S(_({epoch:f(),effectiveSlot:f(),amount:f(),postBalance:f(),commission:T(S(f()))})))),Hu=A(_({slot:f(),prioritizationFee:f()})),qu=_({total:f(),validator:f(),foundation:f(),epoch:f()}),ju=_({epoch:f(),slotIndex:f(),slotsInEpoch:f(),absoluteSlot:f(),blockHeight:T(f()),transactionCount:T(f())}),Yu=_({slotsPerEpoch:f(),leaderScheduleSlotOffset:f(),warmup:ae(),firstNormalEpoch:f(),firstNormalSlot:f()}),Xu=Rn(p(),A(f())),xe=S(Y([_({}),p()])),Ju=_({err:xe}),Zu=F("receivedSignature"),Qu=_({"solana-core":p(),"feature-set":T(f())}),ed=_({program:p(),programId:$,parsed:ve()}),td=_({programId:$,accounts:A($),data:p()}),Xr=G(_({err:S(Y([_({}),p()])),logs:S(A(p())),accounts:T(S(A(S(_({executable:ae(),owner:p(),lamports:f(),data:A(p()),rentEpoch:T(f())}))))),unitsConsumed:T(f()),returnData:T(S(_({programId:p(),data:kt([p(),F("base64")])}))),innerInstructions:T(S(A(_({index:f(),instructions:A(Y([ed,td]))}))))})),nd=G(_({byIdentity:Rn(p(),A(f())),range:_({firstSlot:f(),lastSlot:f()})}));function rd(s,e,t,n,r,o){let i=t||Du,a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=(h,m)=>d(this,null,function*(){let N=yield new Promise((E,R)=>{try{n(h,m,(g,I)=>E([g,I]))}catch(g){R(g)}});return yield i(...N)})),new is.default((h,m)=>d(this,null,function*(){let N={method:"POST",body:h,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},rl)};try{let E=5,R,g=500;for(;c?R=yield c(s,N):R=yield i(s,N),!(R.status!==429||r===!0||(E-=1,E===0));)console.error(`Server responded with ${R.status} ${R.statusText}.  Retrying after ${g}ms delay...`),yield Ve(g),g*=2;let I=yield R.text();R.ok?m(null,I):m(new Error(`${R.status} ${R.statusText}: ${I}`))}catch(E){E instanceof Error&&m(E)}}),{})}function sd(s){return(e,t)=>new Promise((n,r)=>{s.request(e,t,(o,i)=>{if(o){r(o);return}n(i)})})}function od(s){return e=>new Promise((t,n)=>{e.length===0&&t([]);let r=e.map(o=>s.request(o.methodName,o.args));s.request(r,(o,i)=>{if(o){n(o);return}t(i)})})}var id=v(Vu),ad=v(qu),cd=v(Hu),ud=v(ju),dd=v(Yu),ld=v(Xu),fd=v(f()),hd=G(_({total:f(),circulating:f(),nonCirculating:f(),nonCirculatingAccounts:A($)})),Bn=_({amount:p(),uiAmount:S(f()),decimals:f(),uiAmountString:T(p())}),_d=G(A(_({address:$,amount:p(),uiAmount:S(f()),decimals:f(),uiAmountString:T(p())}))),gd=G(A(_({pubkey:$,account:_({executable:ae(),owner:$,lamports:f(),data:$n,rentEpoch:f()})}))),xn=_({program:p(),parsed:ve(),space:f()}),pd=G(A(_({pubkey:$,account:_({executable:ae(),owner:$,lamports:f(),data:xn,rentEpoch:f()})}))),md=G(A(_({lamports:f(),address:$}))),it=_({executable:ae(),owner:$,lamports:f(),data:$n,rentEpoch:f()}),yd=_({pubkey:$,account:it}),Rd=$e(Y([Tt(k.Buffer),xn]),Y([fs,xn]),s=>Array.isArray(s)?y(s,$n):s),Dn=_({executable:ae(),owner:$,lamports:f(),data:Rd,rentEpoch:f()}),Ad=_({pubkey:$,account:Dn}),Sd=_({state:Y([F("active"),F("inactive"),F("activating"),F("deactivating")]),active:f(),inactive:f()}),Ed=v(A(_({signature:p(),slot:f(),err:xe,memo:S(p()),blockTime:T(S(f()))}))),bd=v(A(_({signature:p(),slot:f(),err:xe,memo:S(p()),blockTime:T(S(f()))}))),Id=_({subscription:f(),result:$t(it)}),Od=_({pubkey:$,account:it}),Nd=_({subscription:f(),result:$t(Od)}),wd=_({parent:f(),slot:f(),root:f()}),Td=_({subscription:f(),result:wd}),kd=Y([_({type:Y([F("firstShredReceived"),F("completed"),F("optimisticConfirmation"),F("root")]),slot:f(),timestamp:f()}),_({type:F("createdBank"),parent:f(),slot:f(),timestamp:f()}),_({type:F("frozen"),slot:f(),timestamp:f(),stats:_({numTransactionEntries:f(),numSuccessfulTransactions:f(),numFailedTransactions:f(),maxTransactionsPerEntry:f()})}),_({type:F("dead"),slot:f(),timestamp:f(),err:p()})]),Cd=_({subscription:f(),result:kd}),Ld=_({subscription:f(),result:$t(Y([Ju,Zu]))}),vd=_({subscription:f(),result:f()}),Pd=_({pubkey:p(),gossip:S(p()),tpu:S(p()),rpc:S(p()),version:S(p())}),Jr=_({votePubkey:p(),nodePubkey:p(),activatedStake:f(),epochVoteAccount:ae(),epochCredits:A(kt([f(),f(),f()])),commission:f(),lastVote:f(),rootSlot:S(f())}),Bd=v(_({current:A(Jr),delinquent:A(Jr)})),xd=Y([F("processed"),F("confirmed"),F("finalized")]),Dd=_({slot:f(),confirmations:S(f()),err:xe,confirmationStatus:T(xd)}),Ud=G(A(S(Dd))),Md=v(f()),_s=_({accountKey:$,writableIndexes:A(f()),readonlyIndexes:A(f())}),Vn=_({signatures:A(p()),message:_({accountKeys:A(p()),header:_({numRequiredSignatures:f(),numReadonlySignedAccounts:f(),numReadonlyUnsignedAccounts:f()}),instructions:A(_({accounts:A(f()),data:p(),programIdIndex:f()})),recentBlockhash:p(),addressTableLookups:T(A(_s))})}),gs=_({pubkey:$,signer:ae(),writable:ae(),source:T(Y([F("transaction"),F("lookupTable")]))}),ps=_({accountKeys:A(gs),signatures:A(p())}),ms=_({parsed:ve(),program:p(),programId:$}),ys=_({accounts:A($),data:p(),programId:$}),zd=Y([ys,ms]),Kd=Y([_({parsed:ve(),program:p(),programId:p()}),_({accounts:A(p()),data:p(),programId:p()})]),Rs=$e(zd,Kd,s=>"accounts"in s?y(s,ys):y(s,ms)),As=_({signatures:A(p()),message:_({accountKeys:A(gs),instructions:A(Rs),recentBlockhash:p(),addressTableLookups:T(S(A(_s)))})}),Kt=_({accountIndex:f(),mint:p(),owner:T(p()),programId:T(p()),uiTokenAmount:Bn}),Ss=_({writable:A($),readonly:A($)}),Vt=_({err:xe,fee:f(),innerInstructions:T(S(A(_({index:f(),instructions:A(_({accounts:A(f()),data:p(),programIdIndex:f()}))})))),preBalances:A(f()),postBalances:A(f()),logMessages:T(S(A(p()))),preTokenBalances:T(S(A(Kt))),postTokenBalances:T(S(A(Kt))),loadedAddresses:T(Ss),computeUnitsConsumed:T(f()),costUnits:T(f())}),Gn=_({err:xe,fee:f(),innerInstructions:T(S(A(_({index:f(),instructions:A(Rs)})))),preBalances:A(f()),postBalances:A(f()),logMessages:T(S(A(p()))),preTokenBalances:T(S(A(Kt))),postTokenBalances:T(S(A(Kt))),loadedAddresses:T(Ss),computeUnitsConsumed:T(f()),costUnits:T(f())}),Xe=Y([F(0),F("legacy")]),De=_({pubkey:p(),lamports:f(),postBalance:S(f()),rewardType:S(p()),commission:T(S(f()))}),Wd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),transactions:A(_({transaction:Vn,meta:S(Vt),version:T(Xe)})),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),Fd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),$d=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),transactions:A(_({transaction:ps,meta:S(Vt),version:T(Xe)})),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),Vd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),transactions:A(_({transaction:As,meta:S(Gn),version:T(Xe)})),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),Gd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),transactions:A(_({transaction:ps,meta:S(Gn),version:T(Xe)})),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),Hd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),rewards:T(A(De)),blockTime:S(f()),blockHeight:S(f())}))),qd=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),transactions:A(_({transaction:Vn,meta:S(Vt)})),rewards:T(A(De)),blockTime:S(f())}))),Zr=v(S(_({blockhash:p(),previousBlockhash:p(),parentSlot:f(),signatures:A(p()),blockTime:S(f())}))),On=v(S(_({slot:f(),meta:S(Vt),blockTime:T(S(f())),transaction:Vn,version:T(Xe)}))),Ct=v(S(_({slot:f(),transaction:As,meta:S(Gn),blockTime:T(S(f())),version:T(Xe)}))),jd=G(_({blockhash:p(),lastValidBlockHeight:f()})),Yd=G(ae()),Xd=_({slot:f(),numTransactions:f(),numSlots:f(),samplePeriodSecs:f()}),Jd=v(A(Xd)),Zd=G(S(_({feeCalculator:_({lamportsPerSignature:f()})}))),Qd=v(p()),el=v(p()),tl=_({err:xe,logs:A(p()),signature:p()}),nl=_({result:$t(tl),subscription:f()}),rl={"solana-client":"js/1.0.0-maintenance"},Ie=class{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{let l={};return h=>d(this,null,function*(){let{commitment:m,config:N}=W(h),E=this._buildArgs([],m,void 0,N),R=qr(E);return l[R]=l[R]??d(this,null,function*(){try{let g=yield this._rpcRequest("getBlockHeight",E),I=y(g,v(f()));if("error"in I)throw new O(I.error,"failed to get block height information");return I.result}finally{delete l[R]}}),yield l[R]})})();let n,r,o,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,o=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Fu(e),this._rpcWsEndpoint=n||Ku(e),this._rpcClient=rd(e,r,o,i,a,c),this._rpcRequest=sd(this._rpcClient),this._rpcBatchRequest=od(this._rpcClient),this._rpcWebSocket=new Pn(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}getBalanceAndContext(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgs([e.toBase58()],n,void 0,r),i=yield this._rpcRequest("getBalance",o),a=y(i,G(f()));if("error"in a)throw new O(a.error,`failed to get balance for ${e.toBase58()}`);return a.result})}getBalance(e,t){return d(this,null,function*(){return yield this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})})}getBlockTime(e){return d(this,null,function*(){let t=yield this._rpcRequest("getBlockTime",[e]),n=y(t,v(S(f())));if("error"in n)throw new O(n.error,`failed to get block time for slot ${e}`);return n.result})}getMinimumLedgerSlot(){return d(this,null,function*(){let e=yield this._rpcRequest("minimumLedgerSlot",[]),t=y(e,v(f()));if("error"in t)throw new O(t.error,"failed to get minimum ledger slot");return t.result})}getFirstAvailableBlock(){return d(this,null,function*(){let e=yield this._rpcRequest("getFirstAvailableBlock",[]),t=y(e,fd);if("error"in t)throw new O(t.error,"failed to get first available block");return t.result})}getSupply(e){return d(this,null,function*(){let t={};typeof e=="string"?t={commitment:e}:e?t=L(w({},e),{commitment:e&&e.commitment||this.commitment}):t={commitment:this.commitment};let n=yield this._rpcRequest("getSupply",[t]),r=y(n,hd);if("error"in r)throw new O(r.error,"failed to get supply");return r.result})}getTokenSupply(e,t){return d(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),r=yield this._rpcRequest("getTokenSupply",n),o=y(r,G(Bn));if("error"in o)throw new O(o.error,"failed to get token supply");return o.result})}getTokenAccountBalance(e,t){return d(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),r=yield this._rpcRequest("getTokenAccountBalance",n),o=y(r,G(Bn));if("error"in o)throw new O(o.error,"failed to get token account balance");return o.result})}getTokenAccountsByOwner(e,t,n){return d(this,null,function*(){let{commitment:r,config:o}=W(n),i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});let a=this._buildArgs(i,r,"base64",o),c=yield this._rpcRequest("getTokenAccountsByOwner",a),l=y(c,gd);if("error"in l)throw new O(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result})}getParsedTokenAccountsByOwner(e,t,n){return d(this,null,function*(){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});let o=this._buildArgs(r,n,"jsonParsed"),i=yield this._rpcRequest("getTokenAccountsByOwner",o),a=y(i,pd);if("error"in a)throw new O(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result})}getLargestAccounts(e){return d(this,null,function*(){let t=L(w({},e),{commitment:e&&e.commitment||this.commitment}),n=t.filter||t.commitment?[t]:[],r=yield this._rpcRequest("getLargestAccounts",n),o=y(r,md);if("error"in o)throw new O(o.error,"failed to get largest accounts");return o.result})}getTokenLargestAccounts(e,t){return d(this,null,function*(){let n=this._buildArgs([e.toBase58()],t),r=yield this._rpcRequest("getTokenLargestAccounts",n),o=y(r,_d);if("error"in o)throw new O(o.error,"failed to get token largest accounts");return o.result})}getAccountInfoAndContext(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgs([e.toBase58()],n,"base64",r),i=yield this._rpcRequest("getAccountInfo",o),a=y(i,G(S(it)));if("error"in a)throw new O(a.error,`failed to get info about account ${e.toBase58()}`);return a.result})}getParsedAccountInfo(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=yield this._rpcRequest("getAccountInfo",o),a=y(i,G(S(Dn)));if("error"in a)throw new O(a.error,`failed to get info about account ${e.toBase58()}`);return a.result})}getAccountInfo(e,t){return d(this,null,function*(){try{return(yield this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}})}getMultipleParsedAccounts(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"jsonParsed",r),a=yield this._rpcRequest("getMultipleAccounts",i),c=y(a,G(A(S(Dn))));if("error"in c)throw new O(c.error,`failed to get info for accounts ${o}`);return c.result})}getMultipleAccountsInfoAndContext(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=e.map(l=>l.toBase58()),i=this._buildArgs([o],n,"base64",r),a=yield this._rpcRequest("getMultipleAccounts",i),c=y(a,G(A(S(it))));if("error"in c)throw new O(c.error,`failed to get info for accounts ${o}`);return c.result})}getMultipleAccountsInfo(e,t){return d(this,null,function*(){return(yield this.getMultipleAccountsInfoAndContext(e,t)).value})}getStakeActivation(e,t,n){return d(this,null,function*(){let{commitment:r,config:o}=W(t),i=this._buildArgs([e.toBase58()],r,void 0,L(w({},o),{epoch:n??o?.epoch})),a=yield this._rpcRequest("getStakeActivation",i),c=y(a,v(Sd));if("error"in c)throw new O(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result})}getProgramAccounts(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),m=r||{},{encoding:o}=m,i=le(m,["encoding"]),a=this._buildArgs([e.toBase58()],n,o||"base64",w(w({},i),i.filters?{filters:Yr(i.filters)}:null)),c=yield this._rpcRequest("getProgramAccounts",a),l=A(yd),h=i.withContext===!0?y(c,G(l)):y(c,v(l));if("error"in h)throw new O(h.error,`failed to get accounts owned by program ${e.toBase58()}`);return h.result})}getParsedProgramAccounts(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=yield this._rpcRequest("getProgramAccounts",o),a=y(i,v(A(Ad)));if("error"in a)throw new O(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result})}confirmTransaction(e,t){return d(this,null,function*(){let n;if(typeof e=="string")n=e;else{let o=e;if(o.abortSignal?.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let r;try{r=j.default.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return M(r.length===64,"signature has invalid length"),typeof e=="string"?yield this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?yield this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):yield this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,o=!1,i=new Promise((c,l)=>{try{n=this.onSignature(t,(m,N)=>{n=void 0;let E={context:N,value:m};c({__type:Ae.PROCESSED,response:E})},e);let h=new Promise(m=>{n==null?m():r=this._onSubscriptionStateChange(n,N=>{N==="subscribed"&&m()})});d(this,null,function*(){if(yield h,o)return;let m=yield this.getSignatureStatus(t);if(o||m==null)return;let{context:N,value:E}=m;if(E!=null)if(E?.err)l(E.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(E.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(E.confirmationStatus==="processed"||E.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,c({__type:Ae.PROCESSED,response:{context:N,value:E}})}})}catch(h){l(h)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}confirmTransactionUsingBlockHeightExceedanceStrategy(o){return d(this,arguments,function*({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let i=!1,a=new Promise(N=>{let E=()=>d(this,null,function*(){try{return yield this.getBlockHeight(e)}catch{return-1}});d(this,null,function*(){let R=yield E();if(!i){for(;R<=n;)if(yield Ve(1e3),i||(R=yield E(),i))return;N({__type:Ae.BLOCKHEIGHT_EXCEEDED})}})}),{abortConfirmation:c,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),h=this.getCancellationPromise(t),m;try{let N=yield Promise.race([h,l,a]);if(N.__type===Ae.PROCESSED)m=N.response;else throw new Bt(r)}finally{i=!0,c()}return m})}confirmTransactionUsingDurableNonceStrategy(a){return d(this,arguments,function*({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:o,signature:i}}){let c=!1,l=new Promise(R=>{let g=o,I=null,C=()=>d(this,null,function*(){try{let{context:z,value:V}=yield this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return I=z.slot,V?.nonce}catch{return g}});d(this,null,function*(){if(g=yield C(),!c)for(;;){if(o!==g){R({__type:Ae.NONCE_INVALID,slotInWhichNonceDidAdvance:I});return}if(yield Ve(2e3),c||(g=yield C(),c))return}})}),{abortConfirmation:h,confirmationPromise:m}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),N=this.getCancellationPromise(t),E;try{let R=yield Promise.race([N,m,l]);if(R.__type===Ae.PROCESSED)E=R.response;else{let g;for(;;){let I=yield this.getSignatureStatus(i);if(I==null)break;if(I.context.slot<(R.slotInWhichNonceDidAdvance??n)){yield Ve(400);continue}g=I;break}if(g?.value){let I=e||"finalized",{confirmationStatus:C}=g.value;switch(I){case"processed":case"recent":if(C!=="processed"&&C!=="confirmed"&&C!=="finalized")throw new Pe(i);break;case"confirmed":case"single":case"singleGossip":if(C!=="confirmed"&&C!=="finalized")throw new Pe(i);break;case"finalized":case"max":case"root":if(C!=="finalized")throw new Pe(i);break;default:}E={context:g.context,value:{err:g.value.err}}}else throw new Pe(i)}}finally{c=!0,h()}return E})}confirmTransactionUsingLegacyTimeoutStrategy(n){return d(this,arguments,function*({commitment:e,signature:t}){let r,o=new Promise(l=>{let h=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{h=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>l({__type:Ae.TIMED_OUT,timeoutMs:h}),h)}),{abortConfirmation:i,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:e,signature:t}),c;try{let l=yield Promise.race([a,o]);if(l.__type===Ae.PROCESSED)c=l.response;else throw new xt(t,l.timeoutMs/1e3)}finally{clearTimeout(r),i()}return c})}getClusterNodes(){return d(this,null,function*(){let e=yield this._rpcRequest("getClusterNodes",[]),t=y(e,v(A(Pd)));if("error"in t)throw new O(t.error,"failed to get cluster nodes");return t.result})}getVoteAccounts(e){return d(this,null,function*(){let t=this._buildArgs([],e),n=yield this._rpcRequest("getVoteAccounts",t),r=y(n,Bd);if("error"in r)throw new O(r.error,"failed to get vote accounts");return r.result})}getSlot(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getSlot",r),i=y(o,v(f()));if("error"in i)throw new O(i.error,"failed to get slot");return i.result})}getSlotLeader(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getSlotLeader",r),i=y(o,v(p()));if("error"in i)throw new O(i.error,"failed to get slot leader");return i.result})}getSlotLeaders(e,t){return d(this,null,function*(){let n=[e,t],r=yield this._rpcRequest("getSlotLeaders",n),o=y(r,v(A($)));if("error"in o)throw new O(o.error,"failed to get slot leaders");return o.result})}getSignatureStatus(e,t){return d(this,null,function*(){let{context:n,value:r}=yield this.getSignatureStatuses([e],t);M(r.length===1);let o=r[0];return{context:n,value:o}})}getSignatureStatuses(e,t){return d(this,null,function*(){let n=[e];t&&n.push(t);let r=yield this._rpcRequest("getSignatureStatuses",n),o=y(r,Ud);if("error"in o)throw new O(o.error,"failed to get signature status");return o.result})}getTransactionCount(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getTransactionCount",r),i=y(o,v(f()));if("error"in i)throw new O(i.error,"failed to get transaction count");return i.result})}getTotalSupply(e){return d(this,null,function*(){return(yield this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total})}getInflationGovernor(e){return d(this,null,function*(){let t=this._buildArgs([],e),n=yield this._rpcRequest("getInflationGovernor",t),r=y(n,id);if("error"in r)throw new O(r.error,"failed to get inflation");return r.result})}getInflationReward(e,t,n){return d(this,null,function*(){let{commitment:r,config:o}=W(n),i=this._buildArgs([e.map(l=>l.toBase58())],r,void 0,L(w({},o),{epoch:t??o?.epoch})),a=yield this._rpcRequest("getInflationReward",i),c=y(a,Gu);if("error"in c)throw new O(c.error,"failed to get inflation reward");return c.result})}getInflationRate(){return d(this,null,function*(){let e=yield this._rpcRequest("getInflationRate",[]),t=y(e,ad);if("error"in t)throw new O(t.error,"failed to get inflation rate");return t.result})}getEpochInfo(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getEpochInfo",r),i=y(o,ud);if("error"in i)throw new O(i.error,"failed to get epoch info");return i.result})}getEpochSchedule(){return d(this,null,function*(){let e=yield this._rpcRequest("getEpochSchedule",[]),t=y(e,dd);if("error"in t)throw new O(t.error,"failed to get epoch schedule");let n=t.result;return new vn(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)})}getLeaderSchedule(){return d(this,null,function*(){let e=yield this._rpcRequest("getLeaderSchedule",[]),t=y(e,ld);if("error"in t)throw new O(t.error,"failed to get leader schedule");return t.result})}getMinimumBalanceForRentExemption(e,t){return d(this,null,function*(){let n=this._buildArgs([e],t),r=yield this._rpcRequest("getMinimumBalanceForRentExemption",n),o=y(r,Md);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result})}getRecentBlockhashAndContext(e){return d(this,null,function*(){let{context:t,value:{blockhash:n}}=yield this.getLatestBlockhashAndContext(e);return{context:t,value:{blockhash:n,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}})}getRecentPerformanceSamples(e){return d(this,null,function*(){let t=yield this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=y(t,Jd);if("error"in n)throw new O(n.error,"failed to get recent performance samples");return n.result})}getFeeCalculatorForBlockhash(e,t){return d(this,null,function*(){let n=this._buildArgs([e],t),r=yield this._rpcRequest("getFeeCalculatorForBlockhash",n),o=y(r,Zd);if("error"in o)throw new O(o.error,"failed to get fee calculator");let{context:i,value:a}=o.result;return{context:i,value:a!==null?a.feeCalculator:null}})}getFeeForMessage(e,t){return d(this,null,function*(){let n=x(e.serialize()).toString("base64"),r=this._buildArgs([n],t),o=yield this._rpcRequest("getFeeForMessage",r),i=y(o,G(S(f())));if("error"in i)throw new O(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result})}getRecentPrioritizationFees(e){return d(this,null,function*(){let t=e?.lockedWritableAccounts?.map(i=>i.toBase58()),n=t?.length?[t]:[],r=yield this._rpcRequest("getRecentPrioritizationFees",n),o=y(r,cd);if("error"in o)throw new O(o.error,"failed to get recent prioritization fees");return o.result})}getRecentBlockhash(e){return d(this,null,function*(){try{return(yield this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}})}getLatestBlockhash(e){return d(this,null,function*(){try{return(yield this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}})}getLatestBlockhashAndContext(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,void 0,n),o=yield this._rpcRequest("getLatestBlockhash",r),i=y(o,jd);if("error"in i)throw new O(i.error,"failed to get latest blockhash");return i.result})}isBlockhashValid(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgs([e],n,void 0,r),i=yield this._rpcRequest("isBlockhashValid",o),a=y(i,Yd);if("error"in a)throw new O(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result})}getVersion(){return d(this,null,function*(){let e=yield this._rpcRequest("getVersion",[]),t=y(e,v(Qu));if("error"in t)throw new O(t.error,"failed to get version");return t.result})}getGenesisHash(){return d(this,null,function*(){let e=yield this._rpcRequest("getGenesisHash",[]),t=y(e,v(p()));if("error"in t)throw new O(t.error,"failed to get genesis hash");return t.result})}getBlock(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=yield this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=y(i,$d);if("error"in a)throw a.error;return a.result}case"none":{let a=y(i,Fd);if("error"in a)throw a.error;return a.result}default:{let a=y(i,Wd);if("error"in a)throw a.error;let{result:c}=a;return c?L(w({},c),{transactions:c.transactions.map(({transaction:l,meta:h,version:m})=>({meta:h,transaction:L(w({},l),{message:In(m,l.message)}),version:m}))}):null}}}catch(a){throw new O(a,"failed to get confirmed block")}})}getParsedBlock(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=yield this._rpcRequest("getBlock",o);try{switch(r?.transactionDetails){case"accounts":{let a=y(i,Gd);if("error"in a)throw a.error;return a.result}case"none":{let a=y(i,Hd);if("error"in a)throw a.error;return a.result}default:{let a=y(i,Vd);if("error"in a)throw a.error;return a.result}}}catch(a){throw new O(a,"failed to get block")}})}getBlockProduction(e){return d(this,null,function*(){let t,n;if(typeof e=="string")n=e;else if(e){let a=e,{commitment:c}=a,l=le(a,["commitment"]);n=c,t=l}let r=this._buildArgs([],n,"base64",t),o=yield this._rpcRequest("getBlockProduction",r),i=y(o,nd);if("error"in i)throw new O(i.error,"failed to get block production information");return i.result})}getTransaction(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=yield this._rpcRequest("getTransaction",o),a=y(i,On);if("error"in a)throw new O(a.error,"failed to get transaction");let c=a.result;return c&&L(w({},c),{transaction:L(w({},c.transaction),{message:In(c.version,c.transaction.message)})})})}getParsedTransaction(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=yield this._rpcRequest("getTransaction",o),a=y(i,Ct);if("error"in a)throw new O(a.error,"failed to get transaction");return a.result})}getParsedTransactions(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",r)}));return(yield this._rpcBatchRequest(o)).map(c=>{let l=y(c,Ct);if("error"in l)throw new O(l.error,"failed to get transactions");return l.result})})}getTransactions(e,t){return d(this,null,function*(){let{commitment:n,config:r}=W(t),o=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,r)}));return(yield this._rpcBatchRequest(o)).map(c=>{let l=y(c,On);if("error"in l)throw new O(l.error,"failed to get transactions");let h=l.result;return h&&L(w({},h),{transaction:L(w({},h.transaction),{message:In(h.version,h.transaction.message)})})})})}getConfirmedBlock(e,t){return d(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t),r=yield this._rpcRequest("getBlock",n),o=y(r,qd);if("error"in o)throw new O(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");let a=L(w({},i),{transactions:i.transactions.map(({transaction:c,meta:l})=>{let h=new be(c.message);return{meta:l,transaction:L(w({},c),{message:h})}})});return L(w({},a),{transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:B.populate(c.message,c.signatures)}))})})}getBlocks(e,t,n){return d(this,null,function*(){let r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),o=yield this._rpcRequest("getBlocks",r),i=y(o,v(A(f())));if("error"in i)throw new O(i.error,"failed to get blocks");return i.result})}getBlockSignatures(e,t){return d(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=yield this._rpcRequest("getBlock",n),o=y(r,Zr);if("error"in o)throw new O(o.error,"failed to get block");let i=o.result;if(!i)throw new Error("Block "+e+" not found");return i})}getConfirmedBlockSignatures(e,t){return d(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=yield this._rpcRequest("getBlock",n),o=y(r,Zr);if("error"in o)throw new O(o.error,"failed to get confirmed block");let i=o.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i})}getConfirmedTransaction(e,t){return d(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t),r=yield this._rpcRequest("getTransaction",n),o=y(r,On);if("error"in o)throw new O(o.error,"failed to get transaction");let i=o.result;if(!i)return i;let a=new be(i.transaction.message),c=i.transaction.signatures;return L(w({},i),{transaction:B.populate(a,c)})})}getParsedConfirmedTransaction(e,t){return d(this,null,function*(){let n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=yield this._rpcRequest("getTransaction",n),o=y(r,Ct);if("error"in o)throw new O(o.error,"failed to get confirmed transaction");return o.result})}getParsedConfirmedTransactions(e,t){return d(this,null,function*(){let n=e.map(i=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(yield this._rpcBatchRequest(n)).map(i=>{let a=y(i,Ct);if("error"in a)throw new O(a.error,"failed to get confirmed transactions");return a.result})})}getConfirmedSignaturesForAddress(e,t,n){return d(this,null,function*(){let r={},o=yield this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<o));)try{let c=yield this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(r.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=yield this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>i));)try{let c=yield this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(r.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(yield this.getConfirmedSignaturesForAddress2(e,r)).map(c=>c.signature)})}getConfirmedSignaturesForAddress2(e,t,n){return d(this,null,function*(){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=yield this._rpcRequest("getConfirmedSignaturesForAddress2",r),i=y(o,Ed);if("error"in i)throw new O(i.error,"failed to get confirmed signatures for address");return i.result})}getSignaturesForAddress(e,t,n){return d(this,null,function*(){let r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),o=yield this._rpcRequest("getSignaturesForAddress",r),i=y(o,bd);if("error"in i)throw new O(i.error,"failed to get signatures for address");return i.result})}getAddressLookupTable(e,t){return d(this,null,function*(){let{context:n,value:r}=yield this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=new zt({key:e,state:zt.deserialize(r.data)})),{context:n,value:o}})}getNonceAndContext(e,t){return d(this,null,function*(){let{context:n,value:r}=yield this.getAccountInfoAndContext(e,t),o=null;return r!==null&&(o=Ln.fromAccountData(r.data)),{context:n,value:o}})}getNonce(e,t){return d(this,null,function*(){return yield this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})})}requestAirdrop(e,t){return d(this,null,function*(){let n=yield this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=y(n,Qd);if("error"in r)throw new O(r.error,`airdrop to ${e.toBase58()} failed`);return r.result})}_blockhashWithExpiryBlockHeight(e){return d(this,null,function*(){if(!e){for(;this._pollingBlockhash;)yield Ve(100);let n=Date.now()-this._blockhashInfo.lastFetch>=Wu;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return yield this._pollNewBlockhash()})}_pollNewBlockhash(){return d(this,null,function*(){this._pollingBlockhash=!0;try{let e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){let o=yield this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;yield Ve(Cu/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}})}getStakeMinimumDelegation(e){return d(this,null,function*(){let{commitment:t,config:n}=W(e),r=this._buildArgs([],t,"base64",n),o=yield this._rpcRequest("getStakeMinimumDelegation",r),i=y(o,G(f()));if("error"in i)throw new O(i.error,"failed to get stake minimum delegation");return i.result})}simulateTransaction(e,t,n){return d(this,null,function*(){if("message"in e){let g=e.serialize(),I=k.Buffer.from(g).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");let C=t||{};C.encoding="base64","commitment"in C||(C.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(C.innerInstructions=t.innerInstructions);let z=[I,C],V=yield this._rpcRequest("simulateTransaction",z),q=y(V,Xr);if("error"in q)throw new Error("failed to simulate transaction: "+q.error.message);return q.result}let r;if(e instanceof B){let R=e;r=new B,r.feePayer=R.feePayer,r.instructions=e.instructions,r.nonceInfo=R.nonceInfo,r.signatures=R.signatures}else r=B.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");let o=t;if(r.nonceInfo&&o)r.sign(...o);else{let R=this._disableBlockhashCaching;for(;;){let g=yield this._blockhashWithExpiryBlockHeight(R);if(r.lastValidBlockHeight=g.lastValidBlockHeight,r.recentBlockhash=g.blockhash,!o)break;if(r.sign(...o),!r.signature)throw new Error("!signature");let I=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(I)&&!this._blockhashInfo.transactionSignatures.includes(I)){this._blockhashInfo.simulatedSignatures.push(I);break}else R=!0}}let i=r._compile(),a=i.serialize(),l=r._serialize(a).toString("base64"),h={encoding:"base64",commitment:this.commitment};if(n){let R=(Array.isArray(n)?n:i.nonProgramIds()).map(g=>g.toBase58());h.accounts={encoding:"base64",addresses:R}}o&&(h.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(h.innerInstructions=t.innerInstructions);let m=[l,h],N=yield this._rpcRequest("simulateTransaction",m),E=y(N,Xr);if("error"in E){let R;if("data"in E.error&&(R=E.error.data.logs,R&&Array.isArray(R))){let g=`
    `,I=g+R.join(g);console.error(E.error.message,I)}throw new qe({action:"simulate",signature:"",transactionMessage:E.error.message,logs:R})}return E.result})}sendTransaction(e,t,n){return d(this,null,function*(){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");let i=e.serialize();return yield this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");let r=t;if(e.nonceInfo)e.sign(...r);else{let i=this._disableBlockhashCaching;for(;;){let a=yield this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");let c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}let o=e.serialize();return yield this.sendRawTransaction(o,n)})}sendRawTransaction(e,t){return d(this,null,function*(){let n=x(e).toString("base64");return yield this.sendEncodedTransaction(n,t)})}sendEncodedTransaction(e,t){return d(this,null,function*(){let n={encoding:"base64"},r=t&&t.skipPreflight,o=r===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),o&&(n.preflightCommitment=o);let i=[e,n],a=yield this._rpcRequest("sendTransaction",i),c=y(a,el);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new qe({action:r?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:l})}return c.result})}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{d(this,null,function*(){try{yield this._rpcWebSocket.notify("ping")}catch{}})},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,L(w({},n),{state:"pending"}))})}_setSubscription(e,t){let n=this._subscriptionsByHash[e]?.state;if(this._subscriptionsByHash[e]=t,n!==t.state){let r=this._subscriptionStateChangeCallbacksByHash[e];r&&r.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){let n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};let r=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}_updateSubscriptions(){return d(this,null,function*(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}let e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;yield Promise.all(Object.keys(this._subscriptionsByHash).map(n=>d(this,null,function*(){let r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],yield this._updateSubscriptions();return}yield d(this,null,function*(){let{args:o,method:i}=r;try{this._setSubscription(n,L(w({},r),{state:"subscribing"}));let a=yield this._rpcWebSocket.call(i,o);this._setSubscription(n,L(w({},r),{serverSubscriptionId:a,state:"subscribed"})),this._subscriptionCallbacksByServerSubscriptionId[a]=r.callbacks,yield this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:o,error:a}),!t())return;this._setSubscription(n,L(w({},r),{state:"pending"})),yield this._updateSubscriptions()}});break;case"subscribed":r.callbacks.size===0&&(yield d(this,null,function*(){let{serverSubscriptionId:o,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,L(w({},r),{state:"unsubscribing"})),this._setSubscription(n,L(w({},r),{state:"unsubscribing"}));try{yield this._rpcWebSocket.call(i,[o])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,L(w({},r),{state:"subscribed"})),yield this._updateSubscriptions();return}}this._setSubscription(n,L(w({},r),{state:"unsubscribed"})),yield this._updateSubscriptions()}));break}})))})}_handleServerNotification(e,t){let n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(o){console.error(o)}})}_wsOnAccountNotification(e){let{result:t,subscription:n}=y(e,Id);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){let n=this._nextClientSubscriptionId++,r=qr([e.method,t]),o=this._subscriptionsByHash[r];return o===void 0?this._subscriptionsByHash[r]=L(w({},e),{args:t,callbacks:new Set([e.callback]),state:"pending"}):o.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=()=>d(this,null,function*(){delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];let i=this._subscriptionsByHash[r];M(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),yield this._updateSubscriptions()}),this._updateSubscriptions(),n}onAccountChange(e,t,n){let{commitment:r,config:o}=W(n),i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}removeAccountChangeListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"account change")})}_wsOnProgramAccountNotification(e){let{result:t,subscription:n}=y(e,Nd);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){let{commitment:o,config:i}=W(n),a=this._buildArgs([e.toBase58()],o||this._commitment||"finalized","base64",i||(r?{filters:Yr(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}removeProgramAccountChangeListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"program account change")})}onLogs(e,t,n){let r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}removeOnLogsListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"logs")})}_wsOnLogsNotification(e){let{result:t,subscription:n}=y(e,nl);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){let{result:t,subscription:n}=y(e,Td);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}removeSlotChangeListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"slot change")})}_wsOnSlotUpdatesNotification(e){let{result:t,subscription:n}=y(e,Cd);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}removeSlotUpdateListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"slot update")})}_unsubscribeClientSubscription(e,t){return d(this,null,function*(){let n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?yield n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)})}_buildArgs(e,t,n,r){let o=t||this._commitment;if(o||n||r){let i={};n&&(i.encoding=n),o&&(i.commitment=o),r&&(i=Object.assign(i,r)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){let o=t||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){let{result:t,subscription:n}=y(e,Ld);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){let r=this._buildArgs([e],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return o}onSignatureWithOptions(e,t,n){let c=L(w({},n),{commitment:n&&n.commitment||this._commitment||"finalized"}),{commitment:r}=c,o=le(c,["commitment"]),i=this._buildArgs([e],r,void 0,o),a=this._makeSubscription({callback:(l,h)=>{t(l,h);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}removeSignatureListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"signature result")})}_wsOnRootNotification(e){let{result:t,subscription:n}=y(e,vd);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}removeRootChangeListener(e){return d(this,null,function*(){yield this._unsubscribeClientSubscription(e,"root change")})}},Un=class s{constructor(e){this._keypair=void 0,this._keypair=e??Fr()}static generate(){return new s(Fr())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");let n=e.slice(32,64);if(!t||!t.skipValidation){let r=e.slice(0,32),o=kn(r);for(let i=0;i<32;i++)if(n[i]!==o[i])throw new Error("provided secretKey is invalid")}return new s({publicKey:n,secretKey:e})}static fromSeed(e){let t=kn(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new s({publicKey:t,secretKey:n})}get publicKey(){return new b(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}},st=Object.freeze({CreateLookupTable:{index:0,layout:u.struct([u.u32("instruction"),je("recentSlot"),u.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:u.struct([u.u32("instruction")])},ExtendLookupTable:{index:2,layout:u.struct([u.u32("instruction"),je(),u.seq(P(),u.offset(u.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:u.struct([u.u32("instruction")])},CloseLookupTable:{index:4,layout:u.struct([u.u32("instruction")])}});var Mn=class{constructor(){}static createLookupTable(e){let[t,n]=b.findProgramAddressSync([e.authority.toBuffer(),pn().encode(e.recentSlot)],this.programId),r=st.CreateLookupTable,o=D(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Z.programId,isSigner:!1,isWritable:!1}];return[new U({programId:this.programId,keys:i,data:o}),t]}static freezeLookupTable(e){let t=st.FreezeLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new U({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){let t=st.ExtendLookupTable,n=D(t,{addresses:e.addresses.map(o=>o.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Z.programId,isSigner:!1,isWritable:!1}),new U({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){let t=st.DeactivateLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new U({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){let t=st.CloseLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new U({programId:this.programId,keys:r,data:n})}};Mn.programId=new b("AddressLookupTab1e1111111111111111111111111");var Lt=Object.freeze({RequestUnits:{index:0,layout:u.struct([u.u8("instruction"),u.u32("units"),u.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:u.struct([u.u8("instruction"),u.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:u.struct([u.u8("instruction"),u.u32("units")])},SetComputeUnitPrice:{index:3,layout:u.struct([u.u8("instruction"),je("microLamports")])}}),_e=class{constructor(){}static requestUnits(e){let t=Lt.RequestUnits,n=D(t,e);return new U({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){let t=Lt.RequestHeapFrame,n=D(t,e);return new U({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){let t=Lt.SetComputeUnitLimit,n=D(t,e);return new U({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){let t=Lt.SetComputeUnitPrice,n=D(t,{microLamports:BigInt(e.microLamports)});return new U({keys:[],programId:this.programId,data:n})}};_e.programId=new b("ComputeBudget111111111111111111111111111111");var Qr=64,es=32,ts=64,ns=u.struct([u.u8("numSignatures"),u.u8("padding"),u.u16("signatureOffset"),u.u16("signatureInstructionIndex"),u.u16("publicKeyOffset"),u.u16("publicKeyInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u16("messageInstructionIndex")]),zn=class s{constructor(){}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,instructionIndex:o}=e;M(t.length===es,`Public Key must be ${es} bytes but received ${t.length} bytes`),M(r.length===ts,`Signature must be ${ts} bytes but received ${r.length} bytes`);let i=ns.span,a=i+t.length,c=a+r.length,l=1,h=k.Buffer.alloc(c+n.length),m=o??65535;return ns.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:m,publicKeyOffset:i,publicKeyInstructionIndex:m,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:m},h),h.fill(t,i),h.fill(r,a),h.fill(n,c),new U({keys:[],programId:s.programId,data:h})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;M(t.length===Qr,`Private key must be ${Qr} bytes but received ${t.length} bytes`);try{let o=Un.fromSecretKey(t),i=o.publicKey.toBytes(),a=Wn(n,o.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};zn.programId=new b("Ed25519SigVerify111111111111111111111111111");var sl=(s,e)=>{let t=Et.sign(s,e);return[t.toCompactRawBytes(),t.recovery]};Et.utils.isValidPrivateKey;var ol=Et.getPublicKey,rs=32,Nn=20,ss=64,il=11,wn=u.struct([u.u8("numSignatures"),u.u16("signatureOffset"),u.u8("signatureInstructionIndex"),u.u16("ethAddressOffset"),u.u8("ethAddressInstructionIndex"),u.u16("messageDataOffset"),u.u16("messageDataSize"),u.u8("messageInstructionIndex"),u.blob(20,"ethAddress"),u.blob(64,"signature"),u.u8("recoveryId")]),Kn=class s{constructor(){}static publicKeyToEthAddress(e){M(e.length===ss,`Public key must be ${ss} bytes but received ${e.length} bytes`);try{return k.Buffer.from(cn(x(e))).slice(-Nn)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){let{publicKey:t,message:n,signature:r,recoveryId:o,instructionIndex:i}=e;return s.createInstructionWithEthAddress({ethAddress:s.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:o,instructionIndex:i})}static createInstructionWithEthAddress(e){let{ethAddress:t,message:n,signature:r,recoveryId:o,instructionIndex:i=0}=e,a;typeof t=="string"?t.startsWith("0x")?a=k.Buffer.from(t.substr(2),"hex"):a=k.Buffer.from(t,"hex"):a=t,M(a.length===Nn,`Address must be ${Nn} bytes but received ${a.length} bytes`);let c=1+il,l=c,h=c+a.length,m=h+r.length+1,N=1,E=k.Buffer.alloc(wn.span+n.length);return wn.encode({numSignatures:N,signatureOffset:h,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:m,messageDataSize:n.length,messageInstructionIndex:i,signature:x(r),ethAddress:x(a),recoveryId:o},E),E.fill(x(n),wn.span),new U({keys:[],programId:s.programId,data:E})}static createInstructionWithPrivateKey(e){let{privateKey:t,message:n,instructionIndex:r}=e;M(t.length===rs,`Private key must be ${rs} bytes but received ${t.length} bytes`);try{let o=x(t),i=ol(o,!1).slice(1),a=k.Buffer.from(cn(x(n))),[c,l]=sl(a,o);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:l,instructionIndex:r})}catch(o){throw new Error(`Error creating instruction; ${o}`)}}};Kn.programId=new b("KeccakSecp256k11111111111111111111111111111");var Es,al=new b("StakeConfig11111111111111111111111111111111");var at=class{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}};Es=at;at.default=new Es(0,0,b.default);var Se=Object.freeze({Initialize:{index:0,layout:u.struct([u.u32("instruction"),Eu(),bu()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),P("newAuthorized"),u.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:u.struct([u.u32("instruction")])},Split:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Withdraw:{index:4,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},Deactivate:{index:5,layout:u.struct([u.u32("instruction")])},Merge:{index:7,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:u.struct([u.u32("instruction"),P("newAuthorized"),u.u32("stakeAuthorizationType"),Ge("authoritySeed"),P("authorityOwner")])}}),tf=Object.freeze({Staker:{index:0},Withdrawer:{index:1}}),Wt=class{constructor(){}static initialize(e){let{stakePubkey:t,authorized:n,lockup:r}=e,o=r||at.default,i=Se.Initialize,a=D(i,{authorized:{staker:x(n.staker.toBuffer()),withdrawer:x(n.withdrawer.toBuffer())},lockup:{unixTimestamp:o.unixTimestamp,epoch:o.epoch,custodian:x(o.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Mt,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new U(c)}static createAccountWithSeed(e){let t=new B;t.add(Z.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static createAccount(e){let t=new B;t.add(Z.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));let{stakePubkey:n,authorized:r,lockup:o}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:o}))}static delegate(e){let{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,o=Se.Delegate,i=D(o);return new B().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1},{pubkey:al,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){let{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:o,custodianPubkey:i}=e,a=Se.Authorize,c=D(a,{newAuthorized:x(r.toBuffer()),stakeAuthorizationType:o.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new B().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){let{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:o,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=Se.AuthorizeWithSeed,h=D(l,{newAuthorized:x(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:r,authorityOwner:x(o.toBuffer())}),m=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1}];return c&&m.push({pubkey:c,isSigner:!0,isWritable:!1}),new B().add({keys:m,programId:this.programId,data:h})}static splitInstruction(e){let{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:o}=e,i=Se.Split,a=D(i,{lamports:o});return new U({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){let n=new B;return n.add(Z.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){let{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,basePubkey:i,seed:a,lamports:c}=e,l=new B;return l.add(Z.allocate({accountPubkey:o,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&l.add(Z.transfer({fromPubkey:e.authorizedPubkey,toPubkey:o,lamports:t})),l.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:o,lamports:c}))}static merge(e){let{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,o=Se.Merge,i=D(o);return new B().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){let{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:o,custodianPubkey:i}=e,a=Se.Withdraw,c=D(a,{lamports:o}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:Sn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new B().add({keys:l,programId:this.programId,data:c})}static deactivate(e){let{stakePubkey:t,authorizedPubkey:n}=e,r=Se.Deactivate,o=D(r);return new B().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}};Wt.programId=new b("Stake11111111111111111111111111111111111111");Wt.space=200;var ot=Object.freeze({InitializeAccount:{index:0,layout:u.struct([u.u32("instruction"),Iu()])},Authorize:{index:1,layout:u.struct([u.u32("instruction"),P("newAuthorized"),u.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:u.struct([u.u32("instruction"),u.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:u.struct([u.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:u.struct([u.u32("instruction"),Ou()])}}),nf=Object.freeze({Voter:{index:0},Withdrawer:{index:1}}),Ft=class s{constructor(){}static initializeAccount(e){let{votePubkey:t,nodePubkey:n,voteInit:r}=e,o=ot.InitializeAccount,i=D(o,{voteInit:{nodePubkey:x(r.nodePubkey.toBuffer()),authorizedVoter:x(r.authorizedVoter.toBuffer()),authorizedWithdrawer:x(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Mt,isSigner:!1,isWritable:!1},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new U(a)}static createAccount(e){let t=new B;return t.add(Z.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){let{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:o}=e,i=ot.Authorize,a=D(i,{newAuthorized:x(r.toBuffer()),voteAuthorizationType:o.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new B().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){let{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:o,voteAuthorizationType:i,votePubkey:a}=e,c=ot.AuthorizeWithSeed,l=D(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:x(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:x(o.toBuffer()),voteAuthorizationType:i.index}}),h=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:fe,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new B().add({keys:h,programId:this.programId,data:l})}static withdraw(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:o}=e,i=ot.Withdraw,a=D(i,{lamports:r}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new B().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return s.withdraw(e)}static updateValidatorIdentity(e){let{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,o=ot.UpdateValidatorIdentity,i=D(o),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new B().add({keys:a,programId:this.programId,data:i})}};Ft.programId=new b("Vote111111111111111111111111111111111111111");Ft.space=3762;var rf=new b("Va1idator1nfo111111111111111111111111111111"),sf=_({name:p(),website:T(p()),details:T(p()),iconUrl:T(p()),keybaseUsername:T(p())});var of=new b("Vote111111111111111111111111111111111111111"),af=u.struct([P("nodePubkey"),P("authorizedWithdrawer"),u.u8("commission"),u.nu64(),u.seq(u.struct([u.nu64("slot"),u.u32("confirmationCount")]),u.offset(u.u32(),-8),"votes"),u.u8("rootSlotValid"),u.nu64("rootSlot"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),P("authorizedVoter")]),u.offset(u.u32(),-8),"authorizedVoters"),u.struct([u.seq(u.struct([P("authorizedPubkey"),u.nu64("epochOfLastAuthorizedSwitch"),u.nu64("targetEpoch")]),32,"buf"),u.nu64("idx"),u.u8("isEmpty")],"priorVoters"),u.nu64(),u.seq(u.struct([u.nu64("epoch"),u.nu64("credits"),u.nu64("prevCredits")]),u.offset(u.u32(),-8),"epochCredits"),u.struct([u.nu64("slot"),u.nu64("timestamp")],"lastTimestamp")]);var bs=1e9;function cl(s){if(s.length>=255)throw new TypeError("Alphabet too long");let e=new Uint8Array(256);for(let l=0;l<e.length;l++)e[l]=255;for(let l=0;l<s.length;l++){let h=s.charAt(l),m=h.charCodeAt(0);if(e[m]!==255)throw new TypeError(h+" is ambiguous");e[m]=l}let t=s.length,n=s.charAt(0),r=Math.log(t)/Math.log(256),o=Math.log(256)/Math.log(t);function i(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";let h=0,m=0,N=0,E=l.length;for(;N!==E&&l[N]===0;)N++,h++;let R=(E-N)*o+1>>>0,g=new Uint8Array(R);for(;N!==E;){let z=l[N],V=0;for(let q=R-1;(z!==0||V<m)&&q!==-1;q--,V++)z+=256*g[q]>>>0,g[q]=z%t>>>0,z=z/t>>>0;if(z!==0)throw new Error("Non-zero carry");m=V,N++}let I=R-m;for(;I!==R&&g[I]===0;)I++;let C=n.repeat(h);for(;I<R;++I)C+=s.charAt(g[I]);return C}function a(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;let h=0,m=0,N=0;for(;l[h]===n;)m++,h++;let E=(l.length-h)*r+1>>>0,R=new Uint8Array(E);for(;h<l.length;){let z=l.charCodeAt(h);if(z>255)return;let V=e[z];if(V===255)return;let q=0;for(let At=E-1;(V!==0||q<N)&&At!==-1;At--,q++)V+=t*R[At]>>>0,R[At]=V%256>>>0,V=V/256>>>0;if(V!==0)throw new Error("Non-zero carry");N=q,h++}let g=E-N;for(;g!==E&&R[g]===0;)g++;let I=new Uint8Array(m+(E-g)),C=m;for(;g!==E;)I[C++]=R[g++];return I}function c(l){let h=a(l);if(h)return h;throw new Error("Non-base"+t+" character")}return{encode:i,decodeUnsafe:a,decode:c}}var Is=cl;var ul="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",X=Is(ul);var gf={detectRpcUrl(s,e){return s.rpcUrls.default.http[0]?.includes(new URL(K.BLOCKCHAIN_API_RPC_URL).hostname)?`${s.rpcUrls.default.http[0]}?chainId=solana:${s.id}&projectId=${e}`:s.rpcUrls.default.http[0]},getChain(s,e){let t=s.find(n=>n.id===e);return t||J.DEFAULT_CHAIN},hexStringToNumber(s){let e=s.startsWith("0x")?s.slice(2):s;return parseInt(e,16)},getAddress(s){return s.publicKey?.toBase58()}};var Je=class extends Error{constructor(e,t){super(e),this.error=t}};var Gt=class extends Je{constructor(){super(...arguments),this.name="WalletAccountError"}};var Ht=class extends Je{constructor(){super(...arguments),this.name="WalletSendTransactionError"}},ct=class extends Je{constructor(){super(...arguments),this.name="WalletSignTransactionError"}},qt=class extends Je{constructor(){super(...arguments),this.name="WalletSignMessageError"}};function ue(s){return"version"in s}var jt="solana:signAndSendTransaction";var Os="solana:signMessage";var ut="solana:signTransaction";var Yt="standard:connect";var Ns="standard:disconnect";var Xt="standard:events";function ws(s){return Yt in s.features&&Xt in s.features&&(jt in s.features||ut in s.features)}function Ts(s){if(typeof s=="string")return`solana:${s}`}var de=class{constructor(){this.listeners={accountsChanged:[],chainChanged:[],connect:[],disconnect:[],pendingTransaction:[],auth_rpcRequest:[],auth_rpcSuccess:[],auth_rpcError:[]}}on(e,t){this.listeners[e].push(t)}removeListener(e,t){this.listeners[e]=this.listeners[e].filter(n=>n!==t)}emit(e,t){this.listeners[e].forEach(n=>n(t))}};var Jt=class extends de{constructor(e){super(),this.id=K.CONNECTOR_ID.AUTH,this.name=K.CONNECTOR_NAMES.AUTH,this.type="AUTH",this.chain=K.CHAIN.SOLANA,this.provider=e.w3mFrameProvider,this.requestedChains=e.chains,this.getActiveChain=e.getActiveChain}get publicKey(){let e=Te.state.chains.get(K.CHAIN.SOLANA)?.accountState?.address;return e?new b(e):void 0}get chains(){let e=this.provider.getAvailableChainIds();return this.requestedChains.filter(t=>e.includes(t.caipNetworkId))}connect(){return d(this,arguments,function*(e={}){let t=e.chainId||this.getActiveChain()?.id,n=fr("solana");if(yield _r.authConnectorAuthenticate({authConnector:this.provider,chainId:Ts(t),socialUri:e.socialUri,preferredAccountType:n,chainNamespace:K.CHAIN.SOLANA}),!this.publicKey)throw new Error("Failed to connect to the wallet");return this.emit("connect",this.publicKey),this.publicKey.toBase58()})}disconnect(){return d(this,null,function*(){yield this.provider.disconnect(),this.emit("disconnect",void 0)})}signMessage(e){return d(this,null,function*(){if(!this.publicKey)throw new Error("Wallet not connected");let t=yield this.provider.request({method:"solana_signMessage",params:{message:X.encode(e),pubkey:this.publicKey.toBase58()},chainNamespace:this.chain});return X.decode(t.signature)})}signTransaction(e){return d(this,null,function*(){let t=yield this.provider.request({method:"solana_signTransaction",params:{transaction:this.serializeTransaction(e)},chainNamespace:this.chain}),n=X.decode(t.transaction);return ue(e)?ce.deserialize(n):B.from(n)})}signAndSendTransaction(e,t){return d(this,null,function*(){let n=this.serializeTransaction(e);return(yield this.provider.request({method:"solana_signAndSendTransaction",params:{transaction:n,options:t},chainNamespace:this.chain})).signature})}sendTransaction(e,t,n){return d(this,null,function*(){let r=yield this.signTransaction(e);return yield t.sendRawTransaction(r.serialize(),n)})}signAllTransactions(e){return d(this,null,function*(){return(yield this.provider.request({method:"solana_signAllTransactions",params:{transactions:e.map(n=>this.serializeTransaction(n))},chainNamespace:this.chain})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid solana_signAllTransactions response");let i=X.decode(n);return ue(o)?ce.deserialize(i):B.from(i)})})}request(e){return d(this,null,function*(){return this.provider.request({method:e.method,params:e.params,chainNamespace:this.chain})})}getAccounts(){return d(this,null,function*(){return this.publicKey?Promise.resolve([{namespace:this.chain,address:this.publicKey.toBase58(),type:"eoa"}]):Promise.resolve([])})}serializeTransaction(e){return X.encode(new Uint8Array(e.serialize({verifySignatures:!1})))}};var Zt=class extends de{constructor(e){super(),this.name="Coinbase Wallet",this.id=ke.ConnectorExplorerIds[K.CONNECTOR_ID.COINBASE_SDK]||this.name,this.explorerId=ke.ConnectorExplorerIds[K.CONNECTOR_ID.COINBASE_SDK],this.type="ANNOUNCED",this.imageUrl="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8Y2lyY2xlIGN4PSI1MTIiIGN5PSI1MTIiIHI9IjUxMiIgZmlsbD0iIzAwNTJGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MiA1MTJDMTUyIDcxMC44MjMgMzEzLjE3NyA4NzIgNTEyIDg3MkM3MTAuODIzIDg3MiA4NzIgNzEwLjgyMyA4NzIgNTEyQzg3MiAzMTMuMTc3IDcxMC44MjMgMTUyIDUxMiAxNTJDMzEzLjE3NyAxNTIgMTUyIDMxMy4xNzcgMTUyIDUxMlpNNDIwIDM5NkM0MDYuNzQ1IDM5NiAzOTYgNDA2Ljc0NSAzOTYgNDIwVjYwNEMzOTYgNjE3LjI1NSA0MDYuNzQ1IDYyOCA0MjAgNjI4SDYwNEM2MTcuMjU1IDYyOCA2MjggNjE3LjI1NSA2MjggNjA0VjQyMEM2MjggNDA2Ljc0NSA2MTcuMjU1IDM5NiA2MDQgMzk2SDQyMFoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=",this.chain=K.CHAIN.SOLANA,this.provider=this,this.coinbase=e.provider,this.requestedChains=e.chains}get chains(){return this.requestedChains.filter(e=>e.id===Ot.id)}get publicKey(){return this.coinbase.publicKey}get imageId(){return ke.ConnectorImageIds[K.CONNECTOR_ID.COINBASE]}connect(){return d(this,null,function*(){try{yield this.coinbase.connect();let e=this.getAccount(!0);return this.coinbase.emit("connect",this.coinbase.publicKey),this.emit("connect",e),e.toBase58()}catch(e){throw this.coinbase.emit("error",e),new St(e)}})}disconnect(){return d(this,null,function*(){yield this.coinbase.disconnect(),this.coinbase.emit("disconnect",void 0),this.emit("disconnect",void 0)})}signMessage(e){return d(this,null,function*(){return(yield this.coinbase.signMessage(e)).signature})}signTransaction(e){return d(this,null,function*(){return this.coinbase.signTransaction(e)})}signAndSendTransaction(e,t){return d(this,null,function*(){return(yield this.coinbase.signAndSendTransaction(e,t)).signature})}sendTransaction(e,t,n){return d(this,null,function*(){let r=yield this.signTransaction(e);return yield t.sendRawTransaction(r.serialize(),n)})}signAllTransactions(e){return d(this,null,function*(){return yield this.coinbase.signAllTransactions(e)})}request(e){return d(this,null,function*(){return Promise.reject(new Error('The "request" method is not supported on Coinbase Wallet'))})}getAccounts(){return d(this,null,function*(){let e=this.getAccount();return e?Promise.resolve([{namespace:this.chain,address:e.toBase58(),type:"eoa"}]):Promise.resolve([])})}getAccount(e){let t=this.coinbase.publicKey;if(e&&!t)throw new Error("Not connected");return t}};var dt=class extends Error{constructor(e){super(`The wallet does not support the "${e}" feature`)}},lt=class extends Error{constructor(e){super(`The method "${e}" is not supported by the wallet`)}};var dl=function(s,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(s):n?n.value:e.get(s)},Hn,ft=class s extends gr{constructor({provider:e,chains:t,getActiveChain:n}){super({caipNetworks:t,namespace:"solana",provider:e}),this.eventEmitter=new de,this.emit=this.eventEmitter.emit.bind(this.eventEmitter),this.on=this.eventEmitter.on.bind(this.eventEmitter),this.removeListener=this.eventEmitter.removeListener.bind(this.eventEmitter),Hn.set(this,"1.0.0"),this.getActiveChain=n}get session(){return this.provider.session}get chains(){return this.sessionChains.map(e=>{let t=e;return t===J.CHAIN_IDS.Deprecated_Mainnet?t=J.CHAIN_IDS.Mainnet:t===J.CHAIN_IDS.Deprecated_Devnet&&(t=J.CHAIN_IDS.Devnet),this.caipNetworks.find(n=>n.caipNetworkId===t)}).filter(Boolean)}get icon(){return dr.state.connectorImages[this.id]}get version(){return dl(this,Hn,"f")}get publicKey(){let e=this.getAccount(!1);if(e)return new b(e.publicKey)}connect(){return d(this,null,function*(){yield ze(s.prototype,this,"connectWalletConnect").call(this);let e=this.getAccount(!0);return this.emit("connect",new b(e.publicKey)),e.address})}disconnect(){return d(this,null,function*(){yield ze(s.prototype,this,"disconnect").call(this),this.emit("disconnect",void 0)})}signMessage(e){return d(this,null,function*(){this.checkIfMethodIsSupported("solana_signMessage");let t=yield this.internalRequest("solana_signMessage",{message:X.encode(e),pubkey:this.getAccount(!0).address});return X.decode(t.signature)})}signTransaction(e){return d(this,null,function*(){this.checkIfMethodIsSupported("solana_signTransaction");let t=this.serializeTransaction(e),n=yield this.internalRequest("solana_signTransaction",w({transaction:t,pubkey:this.getAccount(!0).address},this.getRawRPCParams(e)));if("signature"in n){let o=X.decode(n.signature);return e.addSignature(new b(this.getAccount(!0).publicKey),Buffer.from(o)),e}let r=Buffer.from(n.transaction,"base64");return ue(e)?ce.deserialize(new Uint8Array(r)):B.from(r)})}signAndSendTransaction(e,t){return d(this,null,function*(){this.checkIfMethodIsSupported("solana_signAndSendTransaction");let n=this.serializeTransaction(e),r=yield this.internalRequest("solana_signAndSendTransaction",{transaction:n,pubkey:this.getAccount(!0).address,sendOptions:t});return this.emit("pendingTransaction",void 0),r.signature})}sendTransaction(e,t,n){return d(this,null,function*(){let r=yield this.signTransaction(e),o=yield t.sendRawTransaction(r.serialize(),n);return this.emit("pendingTransaction",void 0),o})}signAllTransactions(e){return d(this,null,function*(){try{return this.checkIfMethodIsSupported("solana_signAllTransactions"),(yield this.internalRequest("solana_signAllTransactions",{transactions:e.map(n=>this.serializeTransaction(n))})).transactions.map((n,r)=>{let o=e[r];if(!o)throw new Error("Invalid transactions response");let i=Buffer.from(n,"base64");return ue(o)?ce.deserialize(new Uint8Array(i)):(this.emit("pendingTransaction",void 0),B.from(i))})}catch(t){if(t instanceof lt){let n=[];for(let r of e)n.push(yield this.signTransaction(r));return n}throw t}})}request(e){return this.internalRequest(e.method,e.params)}getAccounts(){return d(this,null,function*(){let e=this.session?.namespaces.solana?.accounts||[];return Promise.resolve(e.map(t=>({namespace:this.chain,address:ar.parseCaipAddress(t).address,type:"eoa"})))})}setDefaultChain(e){this.provider.setDefaultChain(e)}internalRequest(e,t){let r=this.chains.find(o=>this.getActiveChain()?.id===o.id)?.caipNetworkId;switch(r){case J.CHAIN_IDS.Mainnet:this.sessionChains.includes(J.CHAIN_IDS.Mainnet)||(r=J.CHAIN_IDS.Deprecated_Mainnet);break;case J.CHAIN_IDS.Devnet:this.sessionChains.includes(J.CHAIN_IDS.Devnet)||(r=J.CHAIN_IDS.Deprecated_Devnet);break;default:break}return this.provider?.request({method:e,params:t},r)}get sessionChains(){return et.getChainsFromNamespaces(this.session?.namespaces)}serializeTransaction(e){return Buffer.from(new Uint8Array(e.serialize({verifySignatures:!1}))).toString("base64")}getAccount(e){let t=this.session?.namespaces.solana?.accounts[0];if(!t){if(e)throw new Error("Account not found");return}let n=t.split(":")[2];if(!n){if(e)throw new Error("Address not found");return}return{address:n,publicKey:X.decode(n)}}getRawRPCParams(e){return ue(e)?{}:{feePayer:e.feePayer?.toBase58()??"",instructions:e.instructions.map(t=>({data:X.encode(new Uint8Array(t.data)),keys:t.keys.map(n=>({isWritable:n.isWritable,isSigner:n.isSigner,pubkey:n.pubkey.toBase58()})),programId:t.programId.toBase58()})),recentBlockhash:e.recentBlockhash??""}}checkIfMethodIsSupported(e){if(!this.session?.namespaces.solana?.methods.includes(e))throw new lt(e)}};Hn=new WeakMap;var ht=rr({connection:null}),Ue={state:ht,subscribeKey(s,e){return ir(ht,s,e)},subscribe(s){return sr(ht,()=>s(ht))},setConnection(s){ht.connection=or(s)}};var Q=new b("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),qn=new b("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),_t=new b("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),lh=new b("So11111111111111111111111111111111111111112"),fh=new b("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");var Oe=class extends Error{constructor(e){super(e)}},ge=class extends Oe{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}},Qt=class extends Oe{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}};var Ze=class extends Oe{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}},pe=class extends Oe{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}},en=class extends Oe{constructor(){super(...arguments),this.name="TokenInvalidMintError"}};var tn=class extends Oe{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}};var jn=function(s){return s[s.InitializeMint=0]="InitializeMint",s[s.InitializeAccount=1]="InitializeAccount",s[s.InitializeMultisig=2]="InitializeMultisig",s[s.Transfer=3]="Transfer",s[s.Approve=4]="Approve",s[s.Revoke=5]="Revoke",s[s.SetAuthority=6]="SetAuthority",s[s.MintTo=7]="MintTo",s[s.Burn=8]="Burn",s[s.CloseAccount=9]="CloseAccount",s[s.FreezeAccount=10]="FreezeAccount",s[s.ThawAccount=11]="ThawAccount",s[s.TransferChecked=12]="TransferChecked",s[s.ApproveChecked=13]="ApproveChecked",s[s.MintToChecked=14]="MintToChecked",s[s.BurnChecked=15]="BurnChecked",s[s.InitializeAccount2=16]="InitializeAccount2",s[s.SyncNative=17]="SyncNative",s[s.InitializeAccount3=18]="InitializeAccount3",s[s.InitializeMultisig2=19]="InitializeMultisig2",s[s.InitializeMint2=20]="InitializeMint2",s[s.GetAccountDataSize=21]="GetAccountDataSize",s[s.InitializeImmutableOwner=22]="InitializeImmutableOwner",s[s.AmountToUiAmount=23]="AmountToUiAmount",s[s.UiAmountToAmount=24]="UiAmountToAmount",s[s.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",s[s.TransferFeeExtension=26]="TransferFeeExtension",s[s.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",s[s.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",s[s.Reallocate=29]="Reallocate",s[s.MemoTransferExtension=30]="MemoTransferExtension",s[s.CreateNativeMint=31]="CreateNativeMint",s[s.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",s[s.InterestBearingMintExtension=33]="InterestBearingMintExtension",s[s.CpiGuardExtension=34]="CpiGuardExtension",s[s.InitializePermanentDelegate=35]="InitializePermanentDelegate",s[s.TransferHookExtension=36]="TransferHookExtension",s[s.MetadataPointerExtension=39]="MetadataPointerExtension",s[s.GroupPointerExtension=40]="GroupPointerExtension",s[s.GroupMemberPointerExtension=41]="GroupMemberPointerExtension",s[s.ScaledUiAmountExtension=43]="ScaledUiAmountExtension",s[s.PausableExtension=44]="PausableExtension",s}(jn||{});var Me=oe(We(),1);var gt=function(s){return s[s.Uninitialized=0]="Uninitialized",s[s.Mint=1]="Mint",s[s.Account=2]="Account",s}(gt||{}),nn=1;var Ne=oe(We(),1);var pt=oe(We(),1);var ll=(0,pt.struct)([(0,pt.u8)("m"),(0,pt.u8)("n"),Nt("isInitialized"),H("signer1"),H("signer2"),H("signer3"),H("signer4"),H("signer5"),H("signer6"),H("signer7"),H("signer8"),H("signer9"),H("signer10"),H("signer11")]),rn=ll.span;var Yn=function(s){return s[s.Uninitialized=0]="Uninitialized",s[s.Initialized=1]="Initialized",s[s.Frozen=2]="Frozen",s}(Yn||{}),ks=(0,Ne.struct)([H("mint"),H("owner"),ye("amount"),(0,Ne.u32)("delegateOption"),H("delegate"),(0,Ne.u8)("state"),(0,Ne.u32)("isNativeOption"),ye("isNative"),ye("delegatedAmount"),(0,Ne.u32)("closeAuthorityOption"),H("closeAuthority")]),me=ks.span;function Xn(r,o,i){return d(this,arguments,function*(s,e,t,n=Q){let a=yield s.getAccountInfo(e,t);return fl(e,a,n)})}function fl(s,e,t=Q){if(!e)throw new ge;if(!e.owner.equals(t))throw new Ze;if(e.data.length<me)throw new pe;let n=ks.decode(e.data.slice(0,me)),r=Buffer.alloc(0);if(e.data.length>me){if(e.data.length===rn)throw new pe;if(e.data[me]!=gt.Account)throw new Qt;r=e.data.slice(me+nn)}return{address:s,mint:n.mint,owner:n.owner,amount:n.amount,delegate:n.delegateOption?n.delegate:null,delegatedAmount:n.delegatedAmount,isInitialized:n.state!==Yn.Uninitialized,isFrozen:n.state===Yn.Frozen,isNative:!!n.isNativeOption,rentExemptReserve:n.isNativeOption?n.isNative:null,closeAuthority:n.closeAuthorityOption?n.closeAuthority:null,tlvData:r}}function Cs(s,e,t){if(t.length){s.push({pubkey:e,isSigner:!1,isWritable:!1});for(let n of t)s.push({pubkey:n instanceof b?n:n.publicKey,isSigner:!0,isWritable:!1})}else s.push({pubkey:e,isSigner:!0,isWritable:!1});return s}var mt=oe(We(),1);var Ls=(0,mt.struct)([(0,mt.u8)("instruction"),ye("amount"),(0,mt.u8)("decimals")]);function vs(s,e,t,n,r,o,i=[],a=Q){let c=Cs([{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}],n,i),l=Buffer.alloc(Ls.span);return Ls.encode({instruction:jn.TransferChecked,amount:BigInt(r),decimals:o},l),new U({keys:c,programId:a,data:l})}var Ps=(0,Me.struct)([(0,Me.u32)("mintAuthorityOption"),H("mintAuthority"),ye("supply"),(0,Me.u8)("decimals"),Nt("isInitialized"),(0,Me.u32)("freezeAuthorityOption"),H("freezeAuthority")]),Jn=Ps.span;function Bs(r,o,i){return d(this,arguments,function*(s,e,t,n=Q){let a=yield s.getAccountInfo(e,t);return hl(e,a,n)})}function hl(s,e,t=Q){if(!e)throw new ge;if(!e.owner.equals(t))throw new Ze;if(e.data.length<Jn)throw new pe;let n=Ps.decode(e.data.slice(0,Jn)),r=Buffer.alloc(0);if(e.data.length>Jn){if(e.data.length<=me)throw new pe;if(e.data.length===rn)throw new pe;if(e.data[me]!=gt.Mint)throw new en;r=e.data.slice(me+nn)}return{address:s,mintAuthority:n.mintAuthorityOption?n.mintAuthority:null,supply:n.supply,decimals:n.decimals,isInitialized:n.isInitialized,freezeAuthority:n.freezeAuthorityOption?n.freezeAuthority:null,tlvData:r}}function Zn(s,e,t=!1,n=Q,r=_t){if(!t&&!b.isOnCurve(e.toBuffer()))throw new tn;let[o]=b.findProgramAddressSync([e.toBuffer(),n.toBuffer(),s.toBuffer()],r);return o}function xs(s,e,t,n,r=Q,o=_t){return _l(s,e,t,n,Buffer.alloc(0),r,o)}function _l(s,e,t,n,r,o=Q,i=_t){let a=[{pubkey:s,isSigner:!0,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Z.programId,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1}];return new U({keys:a,programId:i,data:r})}function gl(s,e){return d(this,null,function*(){let t=yield s.getAccountInfo(e);if(!t)throw new Error("Mint account not found");if(t.owner.equals(Q))return Q;if(t.owner.equals(qn))return qn;throw new Error("Unknown mint owner program")})}function Ds(o){return d(this,arguments,function*({provider:s,to:e,amount:t,tokenMint:n,connection:r}){if(!s.publicKey)throw new Error("No public key found");if(t<=0)throw new Error("Amount must be greater than 0");try{let i=s.publicKey,a=new b(e),c=new b(n),l=yield gl(r,c),m=(yield Bs(r,c,void 0,l)).decimals;if(m<0)throw new Error("Invalid token decimals");let N=Math.floor(t*10**m),E=Zn(c,i,!1,l),R=Zn(c,a,!1,l);try{if((yield Xn(r,E,void 0,l)).amount<BigInt(N))throw new Error("Insufficient token balance")}catch(q){throw q instanceof ge?new Error("Sender does not have a token account for this mint"):q}let g=!1;try{yield Xn(r,R,void 0,l)}catch(q){if(q instanceof ge)g=!0;else throw q}let I=[],C=g?It.UNIT_LIMIT_WITH_ATA_CREATION:It.UNIT_LIMIT_TRANSFER_ONLY;I.push(_e.setComputeUnitPrice({microLamports:It.UNIT_PRICE_MICRO_LAMPORTS}),_e.setComputeUnitLimit({units:C})),g&&I.push(xs(i,R,a,c,l)),I.push(vs(E,c,R,i,N,m,[],l));let{blockhash:z,lastValidBlockHeight:V}=yield r.getLatestBlockhash();return new B({feePayer:i,blockhash:z,lastValidBlockHeight:V}).add(...I)}catch(i){throw new Error(`Failed to create SPL token transaction: ${i instanceof Error?i.message:"Unknown error"}`)}})}var Us={UNIT_PRICE_MICRO_LAMPORTS:2e7,UNIT_LIMIT:500};function Qn(r){return d(this,arguments,function*({provider:s,to:e,value:t,connection:n}){if(!s.publicKey)throw Error("No public key found");let o=new b(e),i=Math.floor(t*bs),{blockhash:a,lastValidBlockHeight:c}=yield n.getLatestBlockhash(),l=[_e.setComputeUnitPrice({microLamports:Us.UNIT_PRICE_MICRO_LAMPORTS}),_e.setComputeUnitLimit({units:Us.UNIT_LIMIT}),Z.transfer({fromPubkey:s.publicKey,toPubkey:o,lamports:i})];return new B({feePayer:s.publicKey,blockhash:a,lastValidBlockHeight:c}).add(...l)})}var pl=function(s,e,t,n){if(t==="a"&&!n)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(s):n?n.value:e.get(s)},ml=function(s,e,t,n,r){if(n==="m")throw new TypeError("Private method is not writable");if(n==="a"&&!r)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?s!==e||!r:!e.has(s))throw new TypeError("Cannot write private member to an object whose class did not declare it");return n==="a"?r.call(s,t):r?r.value=t:e.set(s,t),t},sn,yt,on=new Set;function yl(s){Rt=void 0,on.add(s)}function Rl(s){Rt=void 0,on.delete(s)}var Qe={};function Ks(){if(yt||(yt=Object.freeze({register:Ms,get:Al,on:Sl}),typeof window>"u"))return yt;let s=Object.freeze({register:Ms});try{window.addEventListener("wallet-standard:register-wallet",({detail:e})=>e(s))}catch(e){console.error(`wallet-standard:register-wallet event listener could not be added
`,e)}try{window.dispatchEvent(new er(s))}catch(e){console.error(`wallet-standard:app-ready event could not be dispatched
`,e)}return yt}function Ms(...s){return s=s.filter(e=>!on.has(e)),s.length?(s.forEach(e=>yl(e)),Qe.register?.forEach(e=>zs(()=>e(...s))),function(){s.forEach(t=>Rl(t)),Qe.unregister?.forEach(t=>zs(()=>t(...s)))}):()=>{}}var Rt;function Al(){return Rt||(Rt=[...on]),Rt}function Sl(s,e){return Qe[s]?.push(e)||(Qe[s]=[e]),function(){Qe[s]=Qe[s]?.filter(n=>e!==n)}}function zs(s){try{s()}catch(e){console.error(e)}}var er=class extends Event{get detail(){return pl(this,sn,"f")}get type(){return"wallet-standard:app-ready"}constructor(e){super("wallet-standard:app-ready",{bubbles:!1,cancelable:!1,composed:!1}),sn.set(this,void 0),ml(this,sn,e,"f")}preventDefault(){throw new Error("preventDefault cannot be called")}stopImmediatePropagation(){throw new Error("stopImmediatePropagation cannot be called")}stopPropagation(){throw new Error("stopPropagation cannot be called")}};sn=new WeakMap;function Ws(s){switch(s){case"processed":case"confirmed":case"finalized":case void 0:return s;case"recent":return"processed";case"single":case"singleGossip":return"confirmed";case"max":case"root":return"finalized";default:return}}var tr={"solana:mainnet":Ot,"solana:testnet":Sr,"solana:devnet":Ar};var an=class extends de{constructor({wallet:e,getActiveChain:t,requestedChains:n}){super(),this.type="ANNOUNCED",this.chain=K.CHAIN.SOLANA,this.provider=this,this.wallet=e,this.getActiveChain=t,this.requestedChains=n,this.name=lr.getConnectorName(e.name)||e.name,this.id=ke.ConnectorExplorerIds[this.name]||this.name,this.explorerId=ke.ConnectorExplorerIds[this.name],this.imageUrl=this.wallet.icon,this.bindEvents()}get chains(){return this.wallet.chains.map(e=>this.requestedChains.find(t=>t.id===e||t.id===tr[e]?.id)).filter(Boolean)}get publicKey(){let e=this.getAccount(!1);if(e)return new b(e.publicKey)}connect(){return d(this,null,function*(){yield this.getWalletFeature(Yt).connect().catch(r=>{throw new St(r)});let t=this.getAccount(!0),n=new b(t.publicKey);return this.emit("connect",n),t.address})}disconnect(){return d(this,null,function*(){yield this.getWalletFeature(Ns).disconnect(),this.emit("disconnect",void 0)})}signMessage(e){return d(this,null,function*(){let t=this.getWalletFeature(Os),n=this.getAccount(!0),[r]=yield t.signMessage({message:e,account:n});if(!r)throw new qt("Empty result");return r.signature})}signTransaction(e){return d(this,null,function*(){let t=this.getWalletFeature(ut),n=this.getAccount(!0),r=this.serializeTransaction(e),[o]=yield t.signTransaction({account:n,transaction:new Uint8Array(r),chain:this.getActiveChainName()});if(!o)throw new ct("Empty result");return this.emit("pendingTransaction",void 0),ue(e)?ce.deserialize(o.signedTransaction):B.from(o.signedTransaction)})}signAndSendTransaction(e,t){return d(this,null,function*(){let n=this.getWalletFeature(jt),r=this.getAccount(!0),[o]=yield n.signAndSendTransaction({account:r,transaction:new Uint8Array(this.serializeTransaction(e)),options:L(w({},t),{preflightCommitment:Ws(t?.preflightCommitment)}),chain:this.getActiveChainName()});if(!o)throw new Ht("Empty result");return this.emit("pendingTransaction",void 0),X.encode(o.signature)})}sendTransaction(e,t,n){return d(this,null,function*(){let r=yield this.signTransaction(e);return yield t.sendRawTransaction(r.serialize(),n)})}signAllTransactions(e){return d(this,null,function*(){let t=this.getWalletFeature(ut),n=this.getAccount(!0),r=this.getActiveChainName();return(yield t.signTransaction(...e.map(i=>({transaction:new Uint8Array(this.serializeTransaction(i)),account:n,chain:r})))).map(({signedTransaction:i},a)=>{let c=e[a];if(!c)throw new ct("Invalid transaction signature response");return this.emit("pendingTransaction",void 0),ue(c)?ce.deserialize(i):B.from(i)})})}request(e){return d(this,null,function*(){return Promise.reject(new dt("request"))})}getAccounts(){return d(this,null,function*(){return Promise.resolve(this.wallet.accounts.map(e=>({namespace:this.chain,address:e.address,type:"eoa"})))})}serializeTransaction(e){return e.serialize({verifySignatures:!1})}getAccount(e){let t=this.wallet.accounts[0];if(e&&!t)throw new Gt;return t}getWalletFeature(e){if(!(e in this.wallet.features))throw new dt(e);return this.wallet.features[e]}getActiveChainName(){let e=Object.entries(tr).find(([,t])=>t.id===this.getActiveChain()?.id);if(!e)throw new Error("Invalid chain id");return e[0]}bindEvents(){this.getWalletFeature(Xt).on("change",t=>{if(t.accounts){let n=t.accounts[0];n&&this.emit("accountsChanged",new b(n.publicKey))}})}};var{get:El,on:Fs}=Ks(),we=[];function Vs(s,e,t){let n=[Fs("register",(...r)=>{we=[...we,...$s(r,s,e)],t(...we)}),Fs("unregister",(...r)=>{we=we.filter(o=>r.some(i=>i.name===o.wallet.name)),t(...we)})];return we=$s(El(),s,e),t(...we),()=>n.forEach(r=>r())}function $s(s,e,t){return s.filter(n=>n.name!=="WalletConnect"&&ws(n)).map(n=>new an({wallet:n,requestedChains:e,getActiveChain:t}))}var bl=[K.CONNECTOR_ID.AUTH,K.CONNECTOR_ID.WALLET_CONNECT],Il=[{pattern:/Attempt to debit an account but found no record of a prior credit/iu,message:"Not enough SOL to cover fees or rent"},{pattern:/Insufficient funds for fee/iu,message:"Not enough SOL to cover fees or rent"},{pattern:/Transfer: insufficient lamports/iu,message:"Not enough SOL to cover this transfer"}],nr=class s extends hr{constructor(e={}){super({adapterType:K.ADAPTER_TYPES.SOLANA,namespace:K.CHAIN.SOLANA}),this.balancePromises={},this.connectionSettings=e.connectionSettings||"confirmed",this.wallets=e.wallets,this.registerWalletStandard=e.registerWalletStandard}construct(e){super.construct(e);let t=Ke.getActiveCaipNetworkId(),r=(e.networks?.find(o=>o.caipNetworkId===t)||e.networks?.[0])?.rpcUrls.default.http[0];r&&Ue.setConnection(new Ie(r,this.connectionSettings))}setAuthProvider(e){this.addConnector(new Jt({w3mFrameProvider:e,getActiveChain:()=>Te.getCaipNetworkByNamespace(this.namespace),chains:this.getCaipNetworks()}))}syncConnectors(){ur.state.projectId||pr.open(mr.ALERT_ERRORS.PROJECT_ID_NOT_CONFIGURED,"error");let e=()=>Te.getActiveCaipNetwork(this.namespace);cr.isClient()&&"coinbaseSolana"in window&&this.addConnector(new Zt({provider:window.coinbaseSolana,chains:this.getCaipNetworks(),getActiveChain:e})),Vs(this.getCaipNetworks(),e,this.addConnector.bind(this))}writeContract(){return d(this,null,function*(){return Promise.resolve({hash:""})})}getCapabilities(){return d(this,null,function*(){return Promise.resolve({})})}grantPermissions(){return d(this,null,function*(){return Promise.resolve({})})}revokePermissions(){return d(this,null,function*(){return Promise.resolve("0x")})}walletGetAssets(e){return d(this,null,function*(){return Promise.resolve({})})}getAccounts(e){return d(this,null,function*(){let t=this.connectors.find(n=>n.id===e.id);return t?{accounts:yield t.getAccounts()}:{accounts:[]}})}signMessage(e){return d(this,null,function*(){let t=e.provider;if(!t)throw new Error("connectionControllerClient:signMessage - provider is undefined");let n=yield t.signMessage(new TextEncoder().encode(e.message));return{signature:X.encode(n)}})}estimateGas(e){return d(this,null,function*(){let t=Ue.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let r=yield(yield Qn({provider:e.provider,connection:t,to:"11111111111111111111111111111111",value:1})).getEstimatedFee(t);return{gas:BigInt(r||0)}})}sendTransaction(e){return d(this,null,function*(){let t=Ue.state.connection;if(!t||!e.provider)throw new Error("Connection is not set");let n=e.provider,r=e.tokenMint?yield Ds({provider:n,connection:t,to:e.to,amount:Number(e.value),tokenMint:e.tokenMint}):yield Qn({provider:n,connection:t,to:e.to,value:Number.isNaN(Number(e.value))?0:Number(e.value)}),o=yield n.sendTransaction(r,t).catch(i=>{if(i instanceof qe){let a=i?.transactionError?.message??i?.message??"",c=i?.logs?.join(" ")??"",l=`${a} ${c}`;for(let{pattern:h,message:m}of Il)if(h.test(l))throw new Error(m)}throw i});return yield new Promise(i=>{let a=setInterval(()=>d(this,null,function*(){(yield t.getSignatureStatus(o))?.value&&(clearInterval(a),i())}),1e3)}),{hash:o}})}parseUnits(){return 0n}formatUnits(){return""}connect(e){return d(this,null,function*(){let t=this.connectors.find(l=>l.id===e.id);if(!t)throw new Error("Provider not found");let n=w(w({},t),e.id===K.CONNECTOR_ID.AUTH?{provider:t}:{}),r=e.rpcUrl||this.getCaipNetworks()?.find(l=>l.id===e.chainId)?.rpcUrls.default.http[0];if(!r)throw new Error(`RPC URL not found for chainId: ${e.chainId}`);let o=this.getConnection({address:e.address,connectorId:t.id,connections:this.connections,connectors:this.connectors});if(o?.account)return this.emit("accountChanged",{address:o.account.address,chainId:o.caipNetwork?.id,connector:n}),{id:t.id,address:o.account.address,chainId:e.chainId,provider:t,type:t.type};let i=yield t.connect({chainId:e.chainId,socialUri:e.socialUri});Ue.setConnection(new Ie(r,this.connectionSettings)),this.emit("accountChanged",{address:i,chainId:e.chainId,connector:n});let a=t.id===K.CONNECTOR_ID.AUTH,c=this.getCaipNetworks()?.find(l=>l.id===e.chainId);return this.addConnection({connectorId:t.id,accounts:[{address:i}],caipNetwork:c,auth:a?{name:Ke.getConnectedSocialProvider(),username:Ke.getConnectedSocialUsername()}:void 0}),t.id!==K.CONNECTOR_ID.WALLET_CONNECT&&this.listenSolanaProviderEvents(t.id,t.provider),{id:t.id,address:i,chainId:e.chainId,provider:t,type:t.type}})}getBalance(e){return d(this,null,function*(){let t=e.address,n=this.getCaipNetworks()?.find(c=>c.id===e.chainId);if(!t)return Promise.resolve({balance:"0.00",symbol:"SOL"});let r=new Ie(n?.rpcUrls?.default?.http?.[0],this.connectionSettings),o=`${n?.caipNetworkId}:${e.address}`,i=this.balancePromises[o];if(i)return i;let a=Ke.getNativeBalanceCacheForCaipAddress(o);return a?{balance:a.balance,symbol:a.symbol}:(this.balancePromises[o]=new Promise(c=>d(this,null,function*(){try{let h=((yield r.getBalance(new b(t)))/J.LAMPORTS_PER_SOL).toString();if(Ke.updateNativeBalanceCache({caipAddress:o,balance:h,symbol:e.caipNetwork?.nativeCurrency.symbol||"SOL",timestamp:Date.now()}),!e.caipNetwork)throw new Error("caipNetwork is required");c({balance:h,symbol:e.caipNetwork?.nativeCurrency.symbol})}catch{c({balance:"0.00",symbol:"SOL"})}})).finally(()=>{delete this.balancePromises[o]}),this.balancePromises[o]||{balance:"0.00",symbol:"SOL"})})}switchNetwork(e){return d(this,null,function*(){yield ze(s.prototype,this,"switchNetwork").call(this,e);let{caipNetwork:t}=e;t?.rpcUrls?.default?.http?.[0]&&Ue.setConnection(new Ie(t.rpcUrls.default.http[0],this.connectionSettings))})}listenProviderEvents(){}listenSolanaProviderEvents(e,t){if(bl.includes(e))return;let n=o=>{this.onAccountsChanged([o.toBase58()],e,!1)},r=()=>this.onDisconnect(e);this.providerHandlers[e]||(t.on("disconnect",r),t.on("accountsChanged",n),t.on("connect",n),this.providerHandlers[e]={provider:t,disconnect:r,accountsChanged:n,chainChanged:()=>{}})}setUniversalProvider(e){return d(this,null,function*(){this.universalProvider=e;let t=K.CONNECTOR_ID.WALLET_CONNECT;et.listenWcProvider({universalProvider:e,namespace:K.CHAIN.SOLANA,onConnect:r=>this.onConnect(r,t),onDisconnect:()=>this.onDisconnect(t),onAccountsChanged:r=>this.onAccountsChanged(r,t,!1)});let n=new ft({provider:e,chains:this.getCaipNetworks(),getActiveChain:()=>Te.getCaipNetworkByNamespace(this.namespace)});if(this.registerWalletStandard){let{SolanaWalletConnectStandardWallet:r}=yield import("./chunk-IMOJQFJT.js");r.register(e)}return this.addConnector(n),Promise.resolve()})}connectWalletConnect(e){return d(this,null,function*(){let t=yield ze(s.prototype,this,"connectWalletConnect").call(this,e),n=this.getCaipNetworks()?.find(o=>o.id===e)?.rpcUrls.default.http[0],r=new Ie(n,this.connectionSettings);return Ue.setConnection(r),t})}disconnect(e){return d(this,null,function*(){if(e.id){let t=this.connectors.find(r=>r.id===e.id);if(!t)throw new Error("Provider not found");let n=this.connections.find(r=>bt.isLowerCaseMatch(r.connectorId,e.id));return yield t.provider.disconnect(),this.deleteConnection(t.id),this.connections.length===0?this.emit("disconnect"):this.emitFirstAvailableConnection(),{connections:n?[n]:[]}}return this.disconnectAll()})}syncConnection(e){return d(this,null,function*(){return this.connect(L(w({},e),{type:""}))})}syncConnections(n){return d(this,arguments,function*({connectToFirstConnector:e,caipNetwork:t}){yield Promise.all(this.connectors.filter(r=>{let{hasDisconnected:o,hasConnected:i}=bt.getConnectorStorageInfo(r.id,this.namespace);return!o&&i}).map(r=>d(this,null,function*(){if(r.id===K.CONNECTOR_ID.WALLET_CONNECT){let o=et.getWalletConnectAccounts(this.universalProvider,this.namespace);o.length>0&&this.addConnection({connectorId:r.id,accounts:o.map(i=>({address:i.address})),caipNetwork:t})}else{let o=yield r.connect({chainId:t?.id});o&&(this.addConnection({connectorId:r.id,accounts:[{address:o}],caipNetwork:t}),this.listenSolanaProviderEvents(r.id,r.provider))}}))),e&&this.emitFirstAvailableConnection()})}getWalletConnectProvider(e){return new ft({provider:e.provider,chains:e.caipNetworks,getActiveChain:()=>Te.getCaipNetworkByNamespace(this.namespace)})}disconnectAll(){return d(this,null,function*(){return{connections:yield Promise.all(this.connections.map(t=>d(this,null,function*(){let n=this.connectors.find(r=>bt.isLowerCaseMatch(r.id,t.connectorId));if(!n)throw new Error("Connector not found");return yield this.disconnect({id:n.id}),t})))}})}};export{It as SPL_COMPUTE_BUDGET_CONSTANTS,J as SolConstantsUtil,gf as SolHelpersUtil,nr as SolanaAdapter};
