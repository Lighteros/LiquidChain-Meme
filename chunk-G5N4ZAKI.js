import{b as Gt}from"./chunk-2CDTKQ3E.js";import{a as Jt,b as we}from"./chunk-VAHX4GR7.js";import{Da as Ut,Ea as $t,Fa as Bt,H as Nt,Ka as zt,La as Wt,N as Rt,Na as ct,O as it,Pa as Ht,Wa as K,Xa as Lt,e as kt,sa as Ft,ta as Dt,u as jt,v as Ot,w as Mt,ya as qt}from"./chunk-AX3MU5C4.js";import{ga as Tt}from"./chunk-5LQ6A2AX.js";import{Eb as Pt,Lb as rt,Q as It,R as mt,V as nt,Xb as ot,Z as L,_ as St,ac as j,ea as _t,eb as Et,fc as J,ia as M,kb as At,lb as pt}from"./chunk-5G3DVQVW.js";import{a as h,b as C,f as S,n as g}from"./chunk-VNDKUXGB.js";var G="2.22.1";var Kt=()=>`@wagmi/core@${G}`;var Vt=function(t,e,n,r){if(n==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?t!==e||!r:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return n==="m"?r:n==="a"?r.call(t):r?r.value:e.get(t)},st,Xt,N=class t extends Error{get docsBaseUrl(){return"https://wagmi.sh/core"}get version(){return Kt()}constructor(e,n={}){super(),st.add(this),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"WagmiCoreError"});let r=n.cause instanceof t?n.cause.details:n.cause?.message?n.cause.message:n.details,i=n.cause instanceof t&&n.cause.docsPath||n.docsPath;this.message=[e||"An error occurred.","",...n.metaMessages?[...n.metaMessages,""]:[],...i?[`Docs: ${this.docsBaseUrl}${i}.html${n.docsSlug?`#${n.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join(`
`),n.cause&&(this.cause=n.cause),this.details=r,this.docsPath=i,this.metaMessages=n.metaMessages,this.shortMessage=e}walk(e){return Vt(this,st,"m",Xt).call(this,this,e)}};st=new WeakSet,Xt=function t(e,n){return n?.(e)?e:e.cause?Vt(this,st,"m",t).call(this,e.cause,n):e};var R=class extends N{constructor(){super("Chain not configured."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ChainNotConfiguredError"})}},V=class extends N{constructor(){super("Connector already connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAlreadyConnectedError"})}},W=class extends N{constructor(){super("Connector not connected."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorNotConnectedError"})}};var X=class extends N{constructor({address:e,connector:n}){super(`Account "${e}" not found for connector "${n.name}".`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorAccountNotFoundError"})}},Z=class extends N{constructor({connectionChainId:e,connectorChainId:n}){super(`The current chain of the connector (id: ${n}) does not match the connection's chain (id: ${e}).`,{metaMessages:[`Current Chain ID:  ${n}`,`Expected Chain ID: ${e}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorChainMismatchError"})}},Q=class extends N{constructor({connector:e}){super(`Connector "${e.name}" unavailable while reconnecting.`,{details:["During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.","All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.","This error commonly occurs for connectors that asynchronously inject after reconnection has already started."].join(" ")}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ConnectorUnavailableReconnectingError"})}};var q=class extends N{constructor(){super("Provider not found."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ProviderNotFoundError"})}},Y=class extends N{constructor({connector:e}){super(`"${e.name}" does not support programmatic chain switching.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SwitchChainNotSupportedError"})}};tt.type="injected";function tt(t={}){let{shimDisconnect:e=!0,unstable_shimAsyncInject:n}=t;function r(){let c=t.target;if(typeof c=="function"){let d=c();if(d)return d}return typeof c=="object"?c:typeof c=="string"?h({},ye[c]??{id:c,name:`${c[0].toUpperCase()}${c.slice(1)}`,provider:`is${c[0].toUpperCase()}${c.slice(1)}`}):{id:"injected",name:"Injected",provider(d){return d?.ethereum}}}let i,o,l,a;return c=>({get icon(){return r().icon},get id(){return r().id},get name(){return r().name},get supportsSimulation(){return!0},type:tt.type,setup(){return g(this,null,function*(){let s=yield this.getProvider();s?.on&&t.target&&(l||(l=this.onConnect.bind(this),s.on("connect",l)),i||(i=this.onAccountsChanged.bind(this),s.on("accountsChanged",i)))})},connect(){return g(this,arguments,function*({chainId:s,isReconnecting:u,withCapabilities:m}={}){let y=yield this.getProvider();if(!y)throw new q;let v=[];if(u)v=yield this.getAccounts().catch(()=>[]);else if(e)try{v=(yield y.request({method:"wallet_requestPermissions",params:[{eth_accounts:{}}]}))[0]?.caveats?.[0]?.value?.map(b=>M(b)),v.length>0&&(v=yield this.getAccounts())}catch(x){let b=x;if(b.code===j.code)throw new j(b);if(b.code===ot.code)throw b}try{!v?.length&&!u&&(v=(yield y.request({method:"eth_requestAccounts"})).map(A=>M(A))),l&&(y.removeListener("connect",l),l=void 0),i||(i=this.onAccountsChanged.bind(this),y.on("accountsChanged",i)),o||(o=this.onChainChanged.bind(this),y.on("chainChanged",o)),a||(a=this.onDisconnect.bind(this),y.on("disconnect",a));let x=yield this.getChainId();return s&&x!==s&&(x=(yield this.switchChain({chainId:s}).catch(A=>{if(A.code===j.code)throw A;return{id:x}}))?.id??x),e&&(yield c.storage?.removeItem(`${this.id}.disconnected`)),t.target||(yield c.storage?.setItem("injected.connected",!0)),{accounts:m?v.map(b=>({address:b,capabilities:{}})):v,chainId:x}}catch(x){let b=x;throw b.code===j.code?new j(b):b.code===ot.code?new ot(b):b}})},disconnect(){return g(this,null,function*(){let s=yield this.getProvider();if(!s)throw new q;o&&(s.removeListener("chainChanged",o),o=void 0),a&&(s.removeListener("disconnect",a),a=void 0),l||(l=this.onConnect.bind(this),s.on("connect",l));try{yield Rt(()=>s.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]}),{timeout:100})}catch{}e&&(yield c.storage?.setItem(`${this.id}.disconnected`,!0)),t.target||(yield c.storage?.removeItem("injected.connected"))})},getAccounts(){return g(this,null,function*(){let s=yield this.getProvider();if(!s)throw new q;return(yield s.request({method:"eth_accounts"})).map(m=>M(m))})},getChainId(){return g(this,null,function*(){let s=yield this.getProvider();if(!s)throw new q;let u=yield s.request({method:"eth_chainId"});return Number(u)})},getProvider(){return g(this,null,function*(){if(typeof window>"u")return;let s,u=r();return typeof u.provider=="function"?s=u.provider(window):typeof u.provider=="string"?s=at(window,u.provider):s=u.provider,s&&!s.removeListener&&("off"in s&&typeof s.off=="function"?s.removeListener=s.off:s.removeListener=()=>{}),s})},isAuthorized(){return g(this,null,function*(){try{if(e&&(yield c.storage?.getItem(`${this.id}.disconnected`))||!t.target&&!(yield c.storage?.getItem("injected.connected")))return!1;if(!(yield this.getProvider())){if(n!==void 0&&n!==!1){let y=()=>g(this,null,function*(){return typeof window<"u"&&window.removeEventListener("ethereum#initialized",y),!!(yield this.getProvider())}),v=typeof n=="number"?n:1e3;if(yield Promise.race([...typeof window<"u"?[new Promise(b=>window.addEventListener("ethereum#initialized",()=>b(y()),{once:!0}))]:[],new Promise(b=>setTimeout(()=>b(y()),v))]))return!0}throw new q}return!!(yield Nt(()=>this.getAccounts())).length}catch{return!1}})},switchChain(m){return g(this,arguments,function*({addEthereumChainParameter:s,chainId:u}){let y=yield this.getProvider();if(!y)throw new q;let v=c.chains.find(A=>A.id===u);if(!v)throw new J(new R);let x=new Promise(A=>{let _=T=>{"chainId"in T&&T.chainId===u&&(c.emitter.off("change",_),A())};c.emitter.on("change",_)});try{return yield Promise.all([y.request({method:"wallet_switchEthereumChain",params:[{chainId:L(u)}]}).then(()=>g(this,null,function*(){(yield this.getChainId())===u&&c.emitter.emit("change",{chainId:u})})),x]),v}catch(A){let _=A;if(_.code===4902||_?.data?.originalError?.code===4902)try{let b=v.blockExplorers??{},{default:T}=b,O=S(b,["default"]),k;s?.blockExplorerUrls?k=s.blockExplorerUrls:T&&(k=[T.url,...Object.values(O).map(p=>p.url)]);let B;s?.rpcUrls?.length?B=s.rpcUrls:B=[v.rpcUrls.default?.http[0]??""];let f={blockExplorerUrls:k,chainId:L(u),chainName:s?.chainName??v.name,iconUrls:s?.iconUrls,nativeCurrency:s?.nativeCurrency??v.nativeCurrency,rpcUrls:B};return yield Promise.all([y.request({method:"wallet_addEthereumChain",params:[f]}).then(()=>g(this,null,function*(){if((yield this.getChainId())===u)c.emitter.emit("change",{chainId:u});else throw new j(new Error("User rejected switch after adding network."))})),x]),v}catch(T){throw new j(T)}throw _.code===j.code?new j(_):new J(_)}})},onAccountsChanged(s){return g(this,null,function*(){if(s.length===0)this.onDisconnect();else if(c.emitter.listenerCount("connect")){let u=(yield this.getChainId()).toString();this.onConnect({chainId:u}),e&&(yield c.storage?.removeItem(`${this.id}.disconnected`))}else c.emitter.emit("change",{accounts:s.map(u=>M(u))})})},onChainChanged(s){let u=Number(s);c.emitter.emit("change",{chainId:u})},onConnect(s){return g(this,null,function*(){let u=yield this.getAccounts();if(u.length===0)return;let m=Number(s.chainId);c.emitter.emit("connect",{accounts:u,chainId:m});let y=yield this.getProvider();y&&(l&&(y.removeListener("connect",l),l=void 0),i||(i=this.onAccountsChanged.bind(this),y.on("accountsChanged",i)),o||(o=this.onChainChanged.bind(this),y.on("chainChanged",o)),a||(a=this.onDisconnect.bind(this),y.on("disconnect",a)))})},onDisconnect(s){return g(this,null,function*(){let u=yield this.getProvider();s&&s.code===1013&&u&&(yield this.getAccounts()).length||(c.emitter.emit("disconnect"),u&&(o&&(u.removeListener("chainChanged",o),o=void 0),a&&(u.removeListener("disconnect",a),a=void 0),l||(l=this.onConnect.bind(this),u.on("connect",l))))})}})}var ye={coinbaseWallet:{id:"coinbaseWallet",name:"Coinbase Wallet",provider(t){return t?.coinbaseWalletExtension?t.coinbaseWalletExtension:at(t,"isCoinbaseWallet")}},metaMask:{id:"metaMask",name:"MetaMask",provider(t){return at(t,e=>{if(!e.isMetaMask||e.isBraveWallet&&!e._events&&!e._state)return!1;let n=["isApexWallet","isAvalanche","isBitKeep","isBlockWallet","isKuCoinWallet","isMathWallet","isOkxWallet","isOKExWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPhantom","isPortal","isRabby","isTokenPocket","isTokenary","isUniswapWallet","isZerion"];for(let r of n)if(e[r])return!1;return!0})}},phantom:{id:"phantom",name:"Phantom",provider(t){return t?.phantom?.ethereum?t.phantom?.ethereum:at(t,"isPhantom")}}};function at(t,e){function n(i){return typeof e=="function"?e(i):typeof e=="string"?i[e]:!0}let r=t.ethereum;if(r?.providers)return r.providers.find(i=>n(i));if(r&&n(r))return r}gt.type="mock";function gt(t){let e=new Map,n=t.features??{defaultConnected:!1},r=n.defaultConnected,i;return o=>({id:"mock",name:"Mock Connector",type:gt.type,setup(){return g(this,null,function*(){i=o.chains[0].id})},connect(){return g(this,arguments,function*({chainId:a,withCapabilities:c}={}){if(n.connectError)throw typeof n.connectError=="boolean"?new j(new Error("Failed to connect.")):n.connectError;let s=yield(yield this.getProvider()).request({method:"eth_requestAccounts"}),u=yield this.getChainId();return a&&u!==a&&(u=(yield this.switchChain({chainId:a})).id),r=!0,{accounts:c?s.map(m=>({address:M(m),capabilities:{foo:{bar:m}}})):s.map(m=>M(m)),chainId:u}})},disconnect(){return g(this,null,function*(){r=!1})},getAccounts(){return g(this,null,function*(){if(!r)throw new W;return(yield(yield this.getProvider()).request({method:"eth_accounts"})).map(d=>M(d))})},getChainId(){return g(this,null,function*(){let c=yield(yield this.getProvider()).request({method:"eth_chainId"});return mt(c,"number")})},isAuthorized(){return g(this,null,function*(){return!n.reconnect||!r?!1:!!(yield this.getAccounts()).length})},switchChain(c){return g(this,arguments,function*({chainId:a}){let d=yield this.getProvider(),s=o.chains.find(u=>u.id===a);if(!s)throw new J(new R);return yield d.request({method:"wallet_switchEthereumChain",params:[{chainId:L(a)}]}),s})},onAccountsChanged(a){a.length===0?this.onDisconnect():o.emitter.emit("change",{accounts:a.map(c=>M(c))})},onChainChanged(a){let c=Number(a);o.emitter.emit("change",{chainId:c})},onDisconnect(a){return g(this,null,function*(){o.emitter.emit("disconnect"),r=!1})},getProvider(){return g(this,arguments,function*({chainId:a}={}){let d=(o.chains.find(u=>u.id===a)??o.chains[0]).rpcUrls.default.http[0];return K({request:y=>g(this,[y],function*({method:u,params:m}){if(u==="eth_chainId")return L(i);if(u==="eth_requestAccounts")return t.accounts;if(u==="eth_signTypedData_v4"&&n.signTypedDataError)throw typeof n.signTypedDataError=="boolean"?new j(new Error("Failed to sign typed data.")):n.signTypedDataError;if(u==="wallet_switchEthereumChain"){if(n.switchChainError)throw typeof n.switchChainError=="boolean"?new j(new Error("Failed to switch chain.")):n.switchChainError;i=mt(m[0].chainId,"number"),this.onChainChanged(i.toString());return}if(u==="wallet_watchAsset"){if(n.watchAssetError)throw typeof n.watchAssetError=="boolean"?new j(new Error("Failed to switch chain.")):n.watchAssetError;return r}if(u==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:m[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:m[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"}}};if(u==="wallet_sendCalls"){let A=[],_=m[0].calls,T=m[0].from;for(let k of _){let{result:B,error:f}=yield it.http(d,{body:{method:"eth_sendTransaction",params:[h(h({},k),typeof T<"u"?{from:T}:{})]}});if(f)throw new rt({body:{method:u,params:m},error:f,url:d});A.push(B)}let O=_t(St(JSON.stringify(_)));return e.set(O,A),{id:O}}if(u==="wallet_getCallsStatus"){let A=e.get(m[0]);if(!A)return{atomic:!1,chainId:"0x1",id:m[0],status:100,receipts:[],version:"2.0.0"};let T=(yield Promise.all(A.map(O=>g(this,null,function*(){let{result:k,error:B}=yield it.http(d,{body:{method:"eth_getTransactionReceipt",params:[O],id:0}});if(B)throw new rt({body:{method:u,params:m},error:B,url:d});return k?{blockHash:k.blockHash,blockNumber:k.blockNumber,gasUsed:k.gasUsed,logs:k.logs,status:k.status,transactionHash:k.transactionHash}:null})))).filter(O=>O!==null);return T.length===0?{atomic:!1,chainId:"0x1",id:m[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:m[0],status:200,receipts:T,version:"2.0.0"}}if(u==="wallet_showCallsStatus")return;if(u==="personal_sign"){if(n.signMessageError)throw typeof n.signMessageError=="boolean"?new j(new Error("Failed to sign message.")):n.signMessageError;u="eth_sign",m=[m[1],m[0]]}let v={method:u,params:m},{error:x,result:b}=yield it.http(d,{body:v});if(x)throw new rt({body:v,error:x,url:d});return b})})({retryCount:0})})}})}function P(t,e,n){let r=t[e.name];if(typeof r=="function")return r;let i=t[n];return typeof i=="function"?i:o=>e(t,o)}function Ce(t,e){return g(this,null,function*(){let n;if(typeof e.connector=="function"?n=t._internal.connectors.setup(e.connector):n=e.connector,n.uid===t.state.current)throw new V;try{t.setState(a=>C(h({},a),{status:"connecting"})),n.emitter.emit("message",{type:"connecting"});let r=e,{connector:i}=r,o=S(r,["connector"]),l=yield n.connect(o);return n.emitter.off("connect",t._internal.events.connect),n.emitter.on("change",t._internal.events.change),n.emitter.on("disconnect",t._internal.events.disconnect),yield t.storage?.setItem("recentConnectorId",n.id),t.setState(a=>C(h({},a),{connections:new Map(a.connections).set(n.uid,{accounts:o.withCapabilities?l.accounts.map(c=>typeof c=="object"?c.address:c):l.accounts,chainId:l.chainId,connector:n}),current:n.uid,status:"connected"})),{accounts:o.withCapabilities?l.accounts.map(a=>typeof a=="object"?a:{address:a,capabilities:{}}):l.accounts,chainId:l.chainId}}catch(i){throw t.setState(o=>C(h({},o),{status:o.current?"connected":"disconnected"})),i}})}function U(n){return g(this,arguments,function*(t,e={}){let{assertChainId:r=!0}=e,i;if(e.connector){let{connector:u}=e;if(t.state.status==="reconnecting"&&!u.getAccounts&&!u.getChainId)throw new Q({connector:u});let[m,y]=yield Promise.all([u.getAccounts().catch(v=>{if(e.account===null)return[];throw v}),u.getChainId()]);i={accounts:m,chainId:y,connector:u}}else i=t.state.connections.get(t.state.current);if(!i)throw new W;let o=e.chainId??i.chainId,l=yield i.connector.getChainId();if(r&&l!==o)throw new Z({connectionChainId:o,connectorChainId:l});let a=i.connector;if(a.getClient)return a.getClient({chainId:o});let c=Et(e.account??i.accounts[0]);if(c&&(c.address=M(c.address)),e.account&&!i.accounts.some(u=>u.toLowerCase()===c.address.toLowerCase()))throw new X({address:c.address,connector:a});let d=t.chains.find(u=>u.id===o),s=yield i.connector.getProvider({chainId:o});return ct({account:c,chain:d,name:"Connector Client",transport:u=>K(s)(C(h({},u),{retryCount:0}))})})}function be(n){return g(this,arguments,function*(t,e={}){let r;if(e.connector)r=e.connector;else{let{connections:o,current:l}=t.state;r=o.get(l)?.connector}let i=t.state.connections;r&&(yield r.disconnect(),r.emitter.off("change",t._internal.events.change),r.emitter.off("disconnect",t._internal.events.disconnect),r.emitter.on("connect",t._internal.events.connect),i.delete(r.uid)),t.setState(o=>{if(i.size===0)return C(h({},o),{connections:new Map,current:null,status:"disconnected"});let l=i.values().next().value;return C(h({},o),{connections:new Map(i),current:l.connector.uid})});{let o=t.state.current;if(!o)return;let l=t.state.connections.get(o)?.connector;if(!l)return;yield t.storage?.setItem("recentConnectorId",l.id)}})}function wt(t){return typeof t=="number"?t:t==="wei"?0:Math.abs(At[t])}function ve(t,e){return g(this,null,function*(){let c=e,{chainId:n,connector:r}=c,i=S(c,["chainId","connector"]),o;e.account?o=e.account:o=(yield U(t,{account:e.account,assertChainId:!1,chainId:n,connector:r})).account;let l=t.getClient({chainId:n});return P(l,Ot,"estimateGas")(C(h({},i),{account:o}))})}function et(t){let e=t.state.current,n=t.state.connections.get(e),r=n?.accounts,i=r?.[0],o=t.chains.find(a=>a.id===n?.chainId),l=t.state.status;switch(l){case"connected":return{address:i,addresses:r,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!0,isConnecting:!1,isDisconnected:!1,isReconnecting:!1,status:l};case"reconnecting":return{address:i,addresses:r,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!!i,isConnecting:!1,isDisconnected:!1,isReconnecting:!0,status:l};case"connecting":return{address:i,addresses:r,chain:o,chainId:n?.chainId,connector:n?.connector,isConnected:!1,isConnecting:!0,isDisconnected:!1,isReconnecting:!1,status:l};case"disconnected":return{address:void 0,addresses:void 0,chain:void 0,chainId:void 0,connector:void 0,isConnected:!1,isConnecting:!1,isDisconnected:!0,isReconnecting:!1,status:l}}}function Zt(t,e){return g(this,null,function*(){let c=e,{allowFailure:n=!0,chainId:r,contracts:i}=c,o=S(c,["allowFailure","chainId","contracts"]),l=t.getClient({chainId:r});return P(l,Dt,"multicall")(h({allowFailure:n,contracts:i},o))})}function Qt(t,e){let l=e,{chainId:n}=l,r=S(l,["chainId"]),i=t.getClient({chainId:n});return P(i,kt,"readContract")(r)}function yt(t,e){return g(this,null,function*(){let a=e,{allowFailure:n=!0,blockNumber:r,blockTag:i}=a,o=S(a,["allowFailure","blockNumber","blockTag"]),l=e.contracts;try{let c={};for(let[m,y]of l.entries()){let v=y.chainId??t.state.chainId;c[v]||(c[v]=[]),c[v]?.push({contract:y,index:m})}let d=()=>Object.entries(c).map(([m,y])=>Zt(t,C(h({},o),{allowFailure:n,blockNumber:r,blockTag:i,chainId:Number.parseInt(m,10),contracts:y.map(({contract:v})=>v)}))),s=(yield Promise.all(d())).flat(),u=Object.values(c).flatMap(m=>m.map(({index:y})=>y));return s.reduce((m,y,v)=>(m&&(m[u[v]]=y),m),[])}catch(c){if(c instanceof Pt)throw c;let d=()=>l.map(s=>Qt(t,C(h({},s),{blockNumber:r,blockTag:i})));return n?(yield Promise.allSettled(d())).map(s=>s.status==="fulfilled"?{result:s.value,status:"success"}:{error:s.reason,result:void 0,status:"failure"}):yield Promise.all(d())}})}function te(t,e){return g(this,null,function*(){let{address:n,blockNumber:r,blockTag:i,chainId:o,token:l,unit:a="ether"}=e;if(l)try{return yield Yt(t,{balanceAddress:n,chainId:o,symbolType:"string",tokenAddress:l})}catch(m){if(m.name==="ContractFunctionExecutionError"){let y=yield Yt(t,{balanceAddress:n,chainId:o,symbolType:"bytes32",tokenAddress:l}),v=nt(It(y.symbol,{dir:"right"}));return C(h({},y),{symbol:v})}throw m}let c=t.getClient({chainId:o}),s=yield P(c,Mt,"getBalance")(r?{address:n,blockNumber:r}:{address:n,blockTag:i}),u=t.chains.find(m=>m.id===o)??c.chain;return{decimals:u.nativeCurrency.decimals,formatted:pt(s,wt(a)),symbol:u.nativeCurrency.symbol,value:s}})}function Yt(t,e){return g(this,null,function*(){let{balanceAddress:n,chainId:r,symbolType:i,tokenAddress:o,unit:l}=e,a={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:i}]}],address:o},[c,d,s]=yield yt(t,{allowFailure:!1,contracts:[C(h({},a),{functionName:"balanceOf",args:[n],chainId:r}),C(h({},a),{functionName:"decimals",chainId:r}),C(h({},a),{functionName:"symbol",chainId:r})]}),u=pt(c??"0",wt(l??d));return{decimals:d,formatted:u,symbol:s,value:c}})}function z(t,e){if(t===e)return!0;if(t&&e&&typeof t=="object"&&typeof e=="object"){if(t.constructor!==e.constructor)return!1;let n,r;if(Array.isArray(t)&&Array.isArray(e)){if(n=t.length,n!==e.length)return!1;for(r=n;r--!==0;)if(!z(t[r],e[r]))return!1;return!0}if(typeof t.valueOf=="function"&&t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(typeof t.toString=="function"&&t.toString!==Object.prototype.toString)return t.toString()===e.toString();let i=Object.keys(t);if(n=i.length,n!==Object.keys(e).length)return!1;for(r=n;r--!==0;)if(!Object.hasOwn(e,i[r]))return!1;for(r=n;r--!==0;){let o=i[r];if(o&&!z(t[o],e[o]))return!1}return!0}return t!==t&&e!==e}function ee(t,e={}){try{return t.getClient(e)}catch{return}}var ut=[];function Ct(t){let e=[...t.state.connections.values()];return t.state.status==="reconnecting"||z(ut,e)?ut:(ut=e,e)}function xe(t,e={}){return ee(t,e)?.extend(Ht)}function Ie(t,e){return g(this,null,function*(){let c=e,{account:n,chainId:r}=c,i=S(c,["account","chainId"]),o=n??et(t).address,l=t.getClient({chainId:r});return P(l,jt,"prepareTransactionRequest")(h(h({},i),o?{account:o}:{}))})}var bt=!1;function Se(n){return g(this,arguments,function*(t,e={}){if(bt)return[];bt=!0,t.setState(s=>C(h({},s),{status:s.current?"reconnecting":"connecting"}));let r=[];if(e.connectors?.length)for(let s of e.connectors){let u;typeof s=="function"?u=t._internal.connectors.setup(s):u=s,r.push(u)}else r.push(...t.connectors);let i;try{i=yield t.storage?.getItem("recentConnectorId")}catch{}let o={};for(let[,s]of t.state.connections)o[s.connector.id]=1;i&&(o[i]=0);let l=Object.keys(o).length>0?[...r].sort((s,u)=>(o[s.id]??10)-(o[u.id]??10)):r,a=!1,c=[],d=[];for(let s of l){let u=yield s.getProvider().catch(()=>{});if(!u||d.some(v=>v===u)||!(yield s.isAuthorized()))continue;let y=yield s.connect({isReconnecting:!0}).catch(()=>null);y&&(s.emitter.off("connect",t._internal.events.connect),s.emitter.on("change",t._internal.events.change),s.emitter.on("disconnect",t._internal.events.disconnect),t.setState(v=>{let x=new Map(a?v.connections:new Map).set(s.uid,{accounts:y.accounts,chainId:y.chainId,connector:s});return C(h({},v),{current:a?v.current:s.uid,connections:x})}),c.push({accounts:y.accounts,chainId:y.chainId,connector:s}),d.push(u),a=!0)}return(t.state.status==="reconnecting"||t.state.status==="connecting")&&(a?t.setState(s=>C(h({},s),{status:"connected"})):t.setState(s=>C(h({},s),{connections:new Map,current:null,status:"disconnected"}))),bt=!1,c})}function _e(t,e){return g(this,null,function*(){let d=e,{account:n,chainId:r,connector:i}=d,o=S(d,["account","chainId","connector"]),l;return typeof n=="object"&&n?.type==="local"?l=t.getClient({chainId:r}):l=yield U(t,{account:n??void 0,assertChainId:!1,chainId:r,connector:i}),yield P(l,Bt,"sendTransaction")(C(h(h({},o),n?{account:n}:{}),{chain:r?{id:r}:null,gas:o.gas??void 0}))})}function Ee(t,e){return g(this,null,function*(){let a=e,{account:n,connector:r}=a,i=S(a,["account","connector"]),o;return typeof n=="object"&&n.type==="local"?o=t.getClient():o=yield U(t,{account:n,connector:r}),P(o,zt,"signMessage")(h(h({},i),n?{account:n}:{}))})}function Ae(t,e){return g(this,null,function*(){let u=e,{abi:n,chainId:r,connector:i}=u,o=S(u,["abi","chainId","connector"]),l;e.account?l=e.account:l=(yield U(t,{assertChainId:!1,chainId:r,connector:i})).account;let a=t.getClient({chainId:r}),c=P(a,qt,"simulateContract"),{result:d,request:s}=yield c(C(h({},o),{abi:n,account:l}));return{chainId:a.chain.id,result:d,request:C(h({},s),{chainId:r})}})}function ne(t,e){return g(this,null,function*(){let{addEthereumChainParameter:n,chainId:r}=e,i=t.state.connections.get(e.connector?.uid??t.state.current);if(i){let l=i.connector;if(!l.switchChain)throw new Y({connector:l});return yield l.switchChain({addEthereumChainParameter:n,chainId:r})}let o=t.chains.find(l=>l.id===r);if(!o)throw new R;return t.setState(l=>C(h({},l),{chainId:r})),o})}function re(t,e){return g(this,null,function*(){let c=e,{chainId:n,timeout:r=0}=c,i=S(c,["chainId","timeout"]),o=t.getClient({chainId:n}),a=yield P(o,Ut,"waitForTransactionReceipt")(C(h({},i),{timeout:r}));if(a.status==="reverted"){let d=yield P(o,Ft,"getTransaction")({hash:a.transactionHash}),{from:u}=d,m=S(d,["from"]),v=yield P(o,Tt,"call")(C(h({},m),{account:u,data:m.input,gasPrice:m.type!=="eip1559"?m.gasPrice:void 0,maxFeePerGas:m.type==="eip1559"?m.maxFeePerGas:void 0,maxPriorityFeePerGas:m.type==="eip1559"?m.maxPriorityFeePerGas:void 0})),x=v?.data?nt(`0x${v.data.substring(138)}`):"unknown reason";throw new Error(x)}return C(h({},a),{chainId:o.chain.id})})}function Pe(t,e){let{onChange:n}=e;return t.subscribe(()=>et(t),n,{equalityFn(r,i){let d=r,{connector:o}=d,l=S(d,["connector"]),s=i,{connector:a}=s,c=S(s,["connector"]);return z(l,c)&&o?.id===a?.id&&o?.uid===a?.uid}})}function Te(t,e){let{onChange:n}=e;return t.subscribe(()=>Ct(t),n,{equalityFn:z})}function ke(t,e){let{onChange:n}=e;return t._internal.connectors.subscribe((r,i)=>{n(Object.values(r),i)})}function je(t,e){let c=e,{syncConnectedChain:n=t._internal.syncConnectedChain}=c,r=S(c,["syncConnectedChain"]),i,o=d=>{i&&i();let s=t.getClient({chainId:d});return i=P(s,$t,"watchPendingTransactions")(r),i},l=o(e.chainId),a;return n&&!e.chainId&&(a=t.subscribe(({chainId:d})=>d,d=>g(this,null,function*(){return o(d)}))),()=>{l?.(),a?.()}}function Oe(t,e){return g(this,null,function*(){let d=e,{account:n,chainId:r,connector:i}=d,o=S(d,["account","chainId","connector"]),l;return typeof n=="object"&&n?.type==="local"?l=t.getClient({chainId:r}):l=yield U(t,{account:n??void 0,assertChainId:!1,chainId:r,connector:i}),yield P(l,Wt,"writeContract")(C(h(h({},o),n?{account:n}:{}),{chain:r?{id:r}:null}))})}var Me=t=>(e,n,r)=>{let i=r.subscribe;return r.subscribe=(l,a,c)=>{let d=l;if(a){let s=c?.equalityFn||Object.is,u=l(r.getState());d=m=>{let y=l(m);if(!s(u,y)){let v=u;a(u=y,v)}},c?.fireImmediately&&a(u,u)}return i(d)},t(e,n,r)},oe=Me;function Ne(t,e){let n;try{n=t()}catch{return}return{getItem:i=>{var o;let l=c=>c===null?null:JSON.parse(c,e?.reviver),a=(o=n.getItem(i))!=null?o:null;return a instanceof Promise?a.then(l):l(a)},setItem:(i,o)=>n.setItem(i,JSON.stringify(o,e?.replacer)),removeItem:i=>n.removeItem(i)}}var vt=t=>e=>{try{let n=t(e);return n instanceof Promise?n:{then(r){return vt(r)(n)},catch(r){return this}}}catch(n){return{then(r){return this},catch(r){return vt(r)(n)}}}},Re=(t,e)=>(n,r,i)=>{let o=h({storage:Ne(()=>localStorage),partialize:x=>x,version:0,merge:(x,b)=>h(h({},b),x)},e),l=!1,a=new Set,c=new Set,d=o.storage;if(!d)return t((...x)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),n(...x)},r,i);let s=()=>{let x=o.partialize(h({},r()));return d.setItem(o.name,{state:x,version:o.version})},u=i.setState;i.setState=(x,b)=>{u(x,b),s()};let m=t((...x)=>{n(...x),s()},r,i);i.getInitialState=()=>m;let y,v=()=>{var x,b;if(!d)return;l=!1,a.forEach(_=>{var T;return _((T=r())!=null?T:m)});let A=((b=o.onRehydrateStorage)==null?void 0:b.call(o,(x=r())!=null?x:m))||void 0;return vt(d.getItem.bind(d))(o.name).then(_=>{if(_)if(typeof _.version=="number"&&_.version!==o.version){if(o.migrate)return[!0,o.migrate(_.state,_.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,_.state];return[!1,void 0]}).then(_=>{var T;let[O,k]=_;if(y=o.merge(k,(T=r())!=null?T:m),n(y,!0),O)return s()}).then(()=>{A?.(y,void 0),y=r(),l=!0,c.forEach(_=>_(y))}).catch(_=>{A?.(void 0,_)})};return i.persist={setOptions:x=>{o=h(h({},o),x),x.storage&&(d=x.storage)},clearStorage:()=>{d?.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>v(),hasHydrated:()=>l,onHydrate:x=>(a.add(x),()=>{a.delete(x)}),onFinishHydration:x=>(c.add(x),()=>{c.delete(x)})},o.skipHydration||v(),y||m},ie=Re;var ce=t=>{let e,n=new Set,r=(d,s)=>{let u=typeof d=="function"?d(e):d;if(!Object.is(u,e)){let m=e;e=s??(typeof u!="object"||u===null)?u:Object.assign({},e,u),n.forEach(y=>y(e,m))}},i=()=>e,a={setState:r,getState:i,getInitialState:()=>c,subscribe:d=>(n.add(d),()=>n.delete(d))},c=e=t(r,i,a);return a},lt=t=>t?ce(t):ce;we();var xt=class{constructor(e){Object.defineProperty(this,"uid",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"_emitter",{enumerable:!0,configurable:!0,writable:!0,value:new Jt.default})}on(e,n){this._emitter.on(e,n)}once(e,n){this._emitter.once(e,n)}off(e,n){this._emitter.off(e,n)}emit(e,...n){let r=n[0];this._emitter.emit(e,h({uid:this.uid},r))}listenerCount(e){return this._emitter.listenerCount(e)}};function se(t){return new xt(t)}function ae(t,e){return JSON.parse(t,(n,r)=>{let i=r;return i?.__type==="bigint"&&(i=BigInt(i.value)),i?.__type==="Map"&&(i=new Map(i.value)),e?.(n,i)??i})}function ue(t,e){return t.slice(0,e).join(".")||"."}function le(t,e){let{length:n}=t;for(let r=0;r<n;++r)if(t[r]===e)return r+1;return 0}function Fe(t,e){let n=typeof t=="function",r=typeof e=="function",i=[],o=[];return function(a,c){if(typeof c=="object")if(i.length){let d=le(i,this);d===0?i[i.length]=this:(i.splice(d),o.splice(d)),o[o.length]=a;let s=le(i,c);if(s!==0)return r?e.call(this,a,c,ue(o,s)):`[ref=${ue(o,s)}]`}else i[0]=c,o[0]=a;return n?t.call(this,a,c):c}}function de(t,e,n,r){return JSON.stringify(t,Fe((i,o)=>{let l=o;return typeof l=="bigint"&&(l={__type:"bigint",value:o.toString()}),l instanceof Map&&(l={__type:"Map",value:Array.from(o.entries())}),e?.(i,l)??l},r),n??void 0)}function fe(t){let{deserialize:e=ae,key:n="wagmi",serialize:r=de,storage:i=he}=t;function o(a){return a instanceof Promise?a.then(c=>c).catch(()=>null):a}return C(h({},i),{key:n,getItem(a,c){return g(this,null,function*(){let d=i.getItem(`${n}.${a}`),s=yield o(d);return s?e(s)??null:c??null})},setItem(a,c){return g(this,null,function*(){let d=`${n}.${a}`;c===null?yield o(i.removeItem(d)):yield o(i.setItem(d,r(c)))})},removeItem(a){return g(this,null,function*(){yield o(i.removeItem(`${n}.${a}`))})}})}var he={getItem:()=>null,setItem:()=>{},removeItem:()=>{}};function me(){let t=typeof window<"u"&&window.localStorage?window.localStorage:he;return{getItem(e){return t.getItem(e)},removeItem(e){t.removeItem(e)},setItem(e,n){try{t.setItem(e,n)}catch{}}}}var dt=256,ft;function pe(t=11){if(!ft||dt+t>256*2){ft="",dt=0;for(let e=0;e<256;e++)ft+=(256+Math.random()*256|0).toString(16).substring(1)}return ft.substring(dt,dt+++t)}function De(t){let k=t,{multiInjectedProviderDiscovery:e=!0,storage:n=fe({storage:me()}),syncConnectedChain:r=!0,ssr:i=!1}=k,o=S(k,["multiInjectedProviderDiscovery","storage","syncConnectedChain","ssr"]),l=typeof window<"u"&&e?Gt():void 0,a=lt(()=>o.chains),c=lt(()=>{let f=[],p=new Set;for(let w of o.connectors??[]){let E=d(w);if(f.push(E),!i&&E.rdns){let I=typeof E.rdns=="string"?[E.rdns]:E.rdns;for(let F of I)p.add(F)}}if(!i&&l){let w=l.getProviders();for(let E of w)p.has(E.info.rdns)||f.push(d(s(E)))}return f});function d(f){let p=se(pe()),w=C(h({},f({emitter:p,chains:a.getState(),storage:n,transports:o.transports})),{emitter:p,uid:p.uid});return p.on("connect",T),w.setup?.(),w}function s(f){let{info:p}=f,w=f.provider;return tt({target:C(h({},p),{id:p.rdns,provider:w})})}let u=new Map;function m(f={}){let p=f.chainId??b.getState().chainId,w=a.getState().find(I=>I.id===p);if(f.chainId&&!w)throw new R;{let I=u.get(b.getState().chainId);if(I&&!w)return I;if(!w)throw new R}{let I=u.get(p);if(I)return I}let E;if(o.client)E=o.client({chain:w});else{let I=w.id,F=a.getState().map(D=>D.id),$={},ht=Object.entries(o);for(let[D,H]of ht)if(!(D==="chains"||D==="client"||D==="connectors"||D==="transports"))if(typeof H=="object")if(I in H)$[D]=H[I];else{if(F.some(ge=>ge in H))continue;$[D]=H}else $[D]=H;E=ct(C(h({},$),{chain:w,batch:$.batch??{multicall:!0},transport:D=>o.transports[I](C(h({},D),{connectors:c}))}))}return u.set(p,E),E}function y(){return{chainId:a.getState()[0].id,connections:new Map,current:null,status:"disconnected"}}let v,x="0.0.0-canary-";G.startsWith(x)?v=Number.parseInt(G.replace(x,""),10):v=Number.parseInt(G.split(".")[0]??"0",10);let b=lt(oe(n?ie(y,{migrate(f,p){if(p===v)return f;let w=y(),E=A(f,w.chainId);return C(h({},w),{chainId:E})},name:"store",partialize(f){return{connections:{__type:"Map",value:Array.from(f.connections.entries()).map(([p,w])=>{let{id:E,name:I,type:F,uid:$}=w.connector,ht={id:E,name:I,type:F,uid:$};return[p,C(h({},w),{connector:ht})]})},chainId:f.chainId,current:f.current}},merge(f,p){typeof f=="object"&&f&&"status"in f&&delete f.status;let w=A(f,p.chainId);return C(h(h({},p),f),{chainId:w})},skipHydration:i,storage:n,version:v}):y));b.setState(y());function A(f,p){return f&&typeof f=="object"&&"chainId"in f&&typeof f.chainId=="number"&&a.getState().some(w=>w.id===f.chainId)?f.chainId:p}r&&b.subscribe(({connections:f,current:p})=>p?f.get(p)?.chainId:void 0,f=>{if(a.getState().some(w=>w.id===f))return b.setState(w=>C(h({},w),{chainId:f??w.chainId}))}),l?.subscribe(f=>{let p=new Set,w=new Set;for(let I of c.getState())if(p.add(I.id),I.rdns){let F=typeof I.rdns=="string"?[I.rdns]:I.rdns;for(let $ of F)w.add($)}let E=[];for(let I of f){if(w.has(I.info.rdns))continue;let F=d(s(I));p.has(F.id)||E.push(F)}n&&!b.persist.hasHydrated()||c.setState(I=>[...I,...E],!0)});function _(f){b.setState(p=>{let w=p.connections.get(f.uid);return w?C(h({},p),{connections:new Map(p.connections).set(f.uid,{accounts:f.accounts??w.accounts,chainId:f.chainId??w.chainId,connector:w.connector})}):p})}function T(f){b.getState().status==="connecting"||b.getState().status==="reconnecting"||b.setState(p=>{let w=c.getState().find(E=>E.uid===f.uid);return w?(w.emitter.listenerCount("connect")&&w.emitter.off("connect",_),w.emitter.listenerCount("change")||w.emitter.on("change",_),w.emitter.listenerCount("disconnect")||w.emitter.on("disconnect",O),C(h({},p),{connections:new Map(p.connections).set(f.uid,{accounts:f.accounts,chainId:f.chainId,connector:w}),current:f.uid,status:"connected"})):p})}function O(f){b.setState(p=>{let w=p.connections.get(f.uid);if(w){let I=w.connector;I.emitter.listenerCount("change")&&w.connector.emitter.off("change",_),I.emitter.listenerCount("disconnect")&&w.connector.emitter.off("disconnect",O),I.emitter.listenerCount("connect")||w.connector.emitter.on("connect",T)}if(p.connections.delete(f.uid),p.connections.size===0)return C(h({},p),{connections:new Map,current:null,status:"disconnected"});let E=p.connections.values().next().value;return C(h({},p),{connections:new Map(p.connections),current:E.connector.uid})})}return{get chains(){return a.getState()},get connectors(){return c.getState()},storage:n,getClient:m,get state(){return b.getState()},setState(f){let p;typeof f=="function"?p=f(b.getState()):p=f;let w=y();typeof p!="object"&&(p=w),Object.keys(w).some(I=>!(I in p))&&(p=w),b.setState(p,!0)},subscribe(f,p,w){return b.subscribe(f,p,w?C(h({},w),{fireImmediately:w.emitImmediately}):void 0)},_internal:{mipd:l,revalidate(){return g(this,null,function*(){let f=b.getState(),p=f.connections,w=f.current;for(let[,E]of p){let I=E.connector;I.isAuthorized&&(yield I.isAuthorized())||(p.delete(I.uid),w===I.uid&&(w=null))}b.setState(E=>C(h({},E),{connections:p,current:w}))})},store:b,ssr:!!i,syncConnectedChain:r,transports:o.transports,chains:{setState(f){let p=typeof f=="function"?f(a.getState()):f;if(p.length!==0)return a.setState(p,!0)},subscribe(f){return a.subscribe(f)}},connectors:{providerDetailToConnector:s,setup:d,setState(f){return c.setState(typeof f=="function"?f(c.getState()):f,!0)},subscribe(f){return c.subscribe(f)}},events:{change:_,connect:T,disconnect:O}}}}function qe(t,e){return Lt(t,e)}function Ue(t){let{chain:e}=t,n=e.rpcUrls.default.http[0];if(!t.transports)return[n];let r=t.transports?.[e.id]?.({chain:e});return(r?.value?.transports||[r]).map(({value:o})=>o?.url||n)}export{R as a,Ce as b,be as c,ve as d,et as e,yt as f,te as g,Ct as h,xe as i,Ie as j,Se as k,_e as l,Ee as m,Ae as n,q as o,ne as p,re as q,Pe as r,Te as s,ke as t,je as u,Oe as v,tt as w,gt as x,De as y,qe as z,Ue as A};
